<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Lorl Studio</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
<style>
/* ‚ïê‚ïê‚ïê RESET & VARS ‚ïê‚ïê‚ïê */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg:       #0c0c16;
  --bg2:      #11111e;
  --bg3:      #18182c;
  --panel:    #14142a;
  --panel2:   #1c1c32;
  --border:   #252540;
  --border2:  #32325a;
  --text:     #e2e2f0;
  --text2:    #8a8aaa;
  --text3:    #555570;
  --accent:   #6c4fff;
  --accent2:  #00e5ff;
  --green:    #00c896;
  --red:      #ff4d6a;
  --yellow:   #ffd500;
  --orange:   #ff8c42;

  --radius:   8px;
  --radius-lg: 12px;
}
html, body { width:100%; height:100%; overflow:hidden; font-family:'Sora',sans-serif; background:var(--bg); color:var(--text); font-size:13px; }

/* ‚ïê‚ïê‚ïê SCROLLBARS ‚ïê‚ïê‚ïê */
::-webkit-scrollbar { width:4px; height:4px; }
::-webkit-scrollbar-track { background:transparent; }
::-webkit-scrollbar-thumb { background:var(--border2); border-radius:4px; }
::-webkit-scrollbar-thumb:hover { background:var(--accent); }

/* ‚ïê‚ïê‚ïê HEADER ‚ïê‚ïê‚ïê */
#header {
  height:44px; background:var(--panel); border-bottom:1px solid var(--border);
  display:flex; align-items:center; padding:0 10px; gap:8px; z-index:50; position:relative;
}
.logo { font-size:16px; font-weight:700; color:var(--accent2); letter-spacing:-0.5px; flex-shrink:0; }
.logo span { color:var(--text2); font-weight:300; }
.hdr-sep { flex:1; }
#project-name {
  background:var(--bg3); border:1px solid var(--border); color:var(--text);
  border-radius:6px; padding:4px 10px; font:500 13px/1 'Sora',sans-serif;
  width:180px; transition:border-color 0.15s;
}
#project-name:focus { outline:none; border-color:var(--accent); }
.hbtn {
  display:flex; align-items:center; gap:5px;
  background:var(--bg3); border:1px solid var(--border2); color:var(--text2);
  border-radius:6px; padding:5px 12px; font:500 12px/1 'Sora',sans-serif;
  cursor:pointer; transition:all 0.15s; white-space:nowrap;
}
.hbtn:hover { border-color:var(--accent); color:var(--text); }
.hbtn.green { background:#00c89618; border-color:var(--green); color:var(--green); }
.hbtn.green:hover { background:var(--green); color:#000; }
.hbtn.purple { background:var(--accent); color:#fff; border-color:var(--accent); }
.hbtn.purple:hover { background:#5a3fe0; }
.hbtn.teal { background:#00e5ff18; border-color:var(--accent2); color:var(--accent2); }

/* ‚ïê‚ïê‚ïê LAYOUT ‚ïê‚ïê‚ïê */
#studio {
  display:grid;
  grid-template-columns: 210px 1fr 272px;
  height:calc(100vh - 44px);
}

/* ‚ïê‚ïê‚ïê LEFT PANEL ‚ïê‚ïê‚ïê */
#left-panel {
  background:var(--panel); border-right:1px solid var(--border);
  display:flex; flex-direction:column; overflow:hidden;
}
.p-head {
  padding:7px 10px 6px; font-size:10px; font-weight:600; letter-spacing:1px;
  color:var(--text2); text-transform:uppercase; border-bottom:1px solid var(--border);
  display:flex; align-items:center; justify-content:space-between; flex-shrink:0;
}
.icon-btn {
  background:none; border:1px solid var(--border2); color:var(--text2);
  border-radius:4px; width:20px; height:20px; cursor:pointer;
  display:flex; align-items:center; justify-content:center; font-size:14px;
  transition:all 0.12s;
}
.icon-btn:hover { border-color:var(--accent); color:var(--accent); }
#object-tree { flex:1; overflow-y:auto; padding:3px; }
.obj-row {
  display:flex; align-items:center; gap:6px;
  padding:5px 8px; border-radius:6px; cursor:pointer;
  color:var(--text2); font-size:12px; transition:all 0.12s;
  border:1px solid transparent; position:relative; user-select:none;
}
.obj-row:hover { background:var(--bg3); color:var(--text); }
.obj-row.selected { background:#6c4fff18; border-color:var(--accent); color:var(--text); }
.obj-icon { font-size:14px; width:18px; text-align:center; flex-shrink:0; }
.obj-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.obj-type { font-size:9px; color:var(--text3); background:var(--bg3); padding:1px 4px; border-radius:8px; }
.obj-del { position:absolute; right:5px; opacity:0; font-size:10px; padding:1px 5px; background:var(--red); color:#fff; border-radius:3px; cursor:pointer; border:none; }
.obj-row:hover .obj-del { opacity:1; }

#props-section { flex-shrink:0; max-height:48%; border-top:1px solid var(--border); display:flex; flex-direction:column; }
#props-content { overflow-y:auto; flex:1; }
.prop-row { display:flex; align-items:center; padding:3px 8px; gap:6px; border-bottom:1px solid #1a1a2a; }
.prop-label { font-size:11px; color:var(--text2); width:60px; flex-shrink:0; }
.prop-input, .prop-select {
  flex:1; background:var(--bg3); border:1px solid var(--border); color:var(--text);
  border-radius:4px; padding:2px 6px; font-size:11px; font-family:'Sora',sans-serif; min-width:0;
}
.prop-input:focus, .prop-select:focus { outline:none; border-color:var(--accent); }
.prop-color { width:36px; height:20px; border:none; border-radius:3px; cursor:pointer; }
.prop-check { cursor:pointer; }

/* ‚ïê‚ïê‚ïê CENTER PANEL ‚ïê‚ïê‚ïê */
#center-panel { display:flex; flex-direction:column; overflow:hidden; min-width:0; }

/* Tab bar */
#tabs {
  display:flex; align-items:center; background:var(--panel); border-bottom:1px solid var(--border);
  padding:0 6px; height:36px; gap:2px; flex-shrink:0;
}
.tab-btn {
  background:none; border:none; color:var(--text2); padding:5px 14px;
  font:500 12px/1 'Sora',sans-serif; cursor:pointer; border-radius:5px 5px 0 0;
  display:flex; align-items:center; gap:5px; transition:all 0.12s;
  border-bottom:2px solid transparent; position:relative; top:1px;
}
.tab-btn:hover { color:var(--text); background:var(--bg3); }
.tab-btn.active { color:var(--accent2); border-bottom-color:var(--accent2); background:var(--bg3); }

.tab-panel { display:none; flex:1; overflow:hidden; }
.tab-panel.active { display:flex; }

/* ‚ïê‚ïê‚ïê BLOCKS TAB ‚ïê‚ïê‚ïê */
#tab-blocks { display:none; }
#tab-blocks.active { display:flex; overflow:hidden; flex:1; }

/* Palette */
#palette {
  width:196px; background:var(--panel); border-right:1px solid var(--border);
  display:flex; flex-direction:column; overflow:hidden; flex-shrink:0;
}
#palette-search-wrap { padding:7px 8px; flex-shrink:0; }
#palette-search {
  width:100%; background:var(--bg3); border:1px solid var(--border); color:var(--text);
  border-radius:6px; padding:5px 9px; font:12px 'Sora',sans-serif;
}
#palette-search:focus { outline:none; border-color:var(--accent); }
#palette-categories { flex:1; overflow-y:auto; padding:2px 5px; }
.pal-cat { margin-bottom:2px; }
.pal-cat-header {
  display:flex; align-items:center; gap:6px; padding:5px 6px 4px;
  cursor:pointer; user-select:none; font-size:10px; font-weight:600;
  letter-spacing:0.5px; color:var(--text2); text-transform:uppercase;
}
.pal-cat-dot { width:7px; height:7px; border-radius:50%; flex-shrink:0; }
.pal-cat-arrow { margin-left:auto; font-size:9px; transition:transform 0.2s; color:var(--text3); }
.pal-cat-arrow.open { transform:rotate(0deg); }
.pal-cat-arrow.closed { transform:rotate(-90deg); }
.pal-cat-blocks { display:flex; flex-direction:column; gap:1px; padding-bottom:3px; }
.pal-block {
  display:flex; align-items:center; gap:7px; padding:5px 8px 5px 6px;
  cursor:grab; border-radius:6px; font-size:11px; color:var(--text);
  border:1px solid transparent; transition:all 0.12s; user-select:none;
}
.pal-block:hover { background:var(--bg3); }
.pal-block:active { cursor:grabbing; }
.pal-block-icon { font-size:13px; width:16px; text-align:center; flex-shrink:0; }
.pal-block-label { flex:1; line-height:1.3; }

/* Block workspace */
#block-canvas-wrap {
  flex:1; overflow:hidden; position:relative; min-width:0;
  background:var(--bg);
  background-image: radial-gradient(circle, var(--border) 1px, transparent 1px);
  background-size: 22px 22px;
}
#block-canvas { position:absolute; top:0; left:0; transform-origin:0 0; }
#canvas-hint {
  position:absolute; inset:0; display:flex; flex-direction:column;
  align-items:center; justify-content:center; gap:10px; pointer-events:none;
}
.canvas-hint-icon { font-size:52px; opacity:0.15; }
.canvas-hint-text { color:var(--text2); font-size:14px; opacity:0.4; text-align:center; line-height:1.7; }
#canvas-toolbar {
  position:absolute; bottom:10px; right:10px;
  background:var(--panel); border:1px solid var(--border); border-radius:8px;
  padding:4px 8px; display:flex; align-items:center; gap:4px;
}
.ctool {
  background:none; border:none; color:var(--text2); cursor:pointer;
  padding:3px 7px; border-radius:4px; font-size:12px;
}
.ctool:hover { background:var(--bg3); color:var(--text); }
#zoom-label { font-size:11px; color:var(--text2); min-width:38px; text-align:center; }

/* ‚îÄ‚îÄ Scratch-style blocks ‚îÄ‚îÄ */
.scratch-stack { position:absolute; user-select:none; }

.scratch-block {
  position:relative;
  min-width:170px;
  filter:drop-shadow(0 3px 10px rgba(0,0,0,.45));
}

.block-main {
  border-radius:6px 6px 0 0;
  position:relative;
}

/* Hat bump (curved top for event blocks) */
.hat-bump {
  position:absolute;
  top:-12px; left:10px;
  width:36px; height:14px;
  border-radius:8px 8px 0 0;
}

.block-row {
  display:flex; align-items:center; gap:7px;
  padding:7px 10px 5px; color:#fff; font-size:12px; font-weight:500;
}
.block-icon { font-size:14px; flex-shrink:0; }
.block-label { flex:1; line-height:1.35; }

.block-fields {
  padding:4px 10px 7px;
  display:flex; flex-direction:column; gap:3px;
  background:rgba(0,0,0,0.25);
  border-top:1px solid rgba(255,255,255,0.08);
  border-radius:0 0 6px 6px;
}
.block-field-row { display:flex; align-items:center; gap:6px; }
.block-field-name { font-size:10px; color:rgba(255,255,255,0.6); min-width:38px; }
.block-input {
  flex:1; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.15);
  color:#fff; border-radius:4px; padding:2px 6px; font-size:11px;
  font-family:'Sora',sans-serif; min-width:0;
}
.block-input:focus, .block-select:focus { outline:none; border-color:rgba(255,255,255,0.5); }
.block-textarea {
  height:48px; resize:vertical; width:100%;
  font-family:'JetBrains Mono',monospace; font-size:11px;
}
.block-select {
  flex:1; background:rgba(0,0,0,0.4); border:1px solid rgba(255,255,255,0.15);
  color:#fff; border-radius:4px; padding:2px 6px; font-size:11px;
  font-family:'Sora',sans-serif;
}
.block-color-input { width:42px; height:22px; border:none; border-radius:4px; cursor:pointer; }

/* Bottom notch (puzzle connector) */
.block-notch-bottom {
  height:5px; background:transparent;
  border-top:5px solid transparent;
  border-left:8px solid;
  border-right:8px solid transparent;
  position:absolute; bottom:-5px; left:12px;
  width:0; height:0;
  border-style:solid;
  border-width:5px 8px 0 8px;
  border-color: inherit transparent transparent transparent;
}

/* C-block (contains inner blocks) */
.block-c-inner {
  margin:0 0 0 18px;
  min-height:28px;
  border:2px dashed rgba(255,255,255,0.12);
  border-radius:4px;
  padding:3px;
}
.c-drop-hint { font-size:10px; color:rgba(255,255,255,0.2); padding:4px 8px; text-align:center; }
.block-else-label { padding:4px 10px; font-size:10px; color:rgba(255,255,255,0.5); font-weight:600; }
.block-c-cap { height:14px; border-radius:0 0 6px 6px; }

/* Value block */
.block-value .block-main { border-radius:12px; }

/* Hat block extra top spacing */
.block-hat { padding-top:14px; }
.block-hat .block-main { border-radius:8px; }

/* Context menu */
.block-ctx-menu { /* defined inline */ }

/* ‚ïê‚ïê‚ïê CODE TAB ‚ïê‚ïê‚ïê */
#tab-code { display:none; }
#tab-code.active { display:flex; overflow:hidden; flex:1; }
#code-sidebar {
  width:155px; background:var(--panel); border-right:1px solid var(--border);
  display:flex; flex-direction:column; overflow:hidden; flex-shrink:0;
}
#script-list { flex:1; overflow-y:auto; }
.script-file {
  display:flex; align-items:center; gap:6px;
  padding:7px 10px; font-size:11px; color:var(--text2);
  cursor:pointer; border-bottom:1px solid var(--border); transition:background 0.1s;
}
.script-file:hover { background:var(--bg3); color:var(--text); }
.script-file.active { background:var(--bg3); color:var(--accent2); border-right:2px solid var(--accent2); }
.sync-tip {
  margin:8px; padding:8px; background:#6c4fff14; border:1px solid #6c4fff44;
  border-radius:6px; font-size:10px; color:var(--accent); line-height:1.6;
}
#code-editor-wrap { flex:1; display:flex; flex-direction:column; min-width:0; }
#code-topbar {
  display:flex; align-items:center; gap:8px; padding:5px 10px;
  background:var(--panel); border-bottom:1px solid var(--border); flex-shrink:0;
}
#code-file-label { font-family:'JetBrains Mono',monospace; font-size:12px; color:var(--text2); flex:1; }
.code-action {
  background:var(--bg3); border:1px solid var(--border); color:var(--text2);
  border-radius:5px; padding:3px 10px; font:12px 'Sora',sans-serif; cursor:pointer;
  transition:all 0.12s;
}
.code-action:hover { border-color:var(--accent); color:var(--text); }
.code-action.sync { border-color:var(--green); color:var(--green); }
#code-box { flex:1; position:relative; overflow:hidden; }
#code-textarea {
  position:absolute; inset:0; width:100%; height:100%;
  background:transparent; border:none; resize:none;
  color:transparent; caret-color:var(--accent2);
  font:13px/1.65 'JetBrains Mono',monospace; padding:12px 12px 12px 54px;
  z-index:2; outline:none; tab-size:2; white-space:pre; overflow:auto;
}
#code-highlight {
  position:absolute; inset:0; overflow:auto; pointer-events:none; z-index:1;
  font:13px/1.65 'JetBrains Mono',monospace; padding:12px 12px 12px 54px;
  white-space:pre; word-break:normal;
}
#code-lines {
  position:absolute; left:0; top:0; bottom:0; width:46px; overflow:hidden;
  background:var(--bg2); border-right:1px solid var(--border); z-index:3;
  font:12px/1.65 'JetBrains Mono',monospace; color:var(--text3);
  padding:12px 7px 12px 4px; text-align:right; user-select:none; pointer-events:none;
}
/* Syntax */
.ck { color:#c792ea; } .cs { color:#c3e88d; } .cn { color:#f78c6c; }
.cc { color:#546e7a; font-style:italic; } .cf { color:#82aaff; } .co { color:#89ddff; }

/* ‚ïê‚ïê‚ïê SCENE TAB ‚ïê‚ïê‚ïê */
#tab-scene { display:none; }
#tab-scene.active { display:flex; flex-direction:column; overflow:hidden; flex:1; }
#scene-toolbar {
  display:flex; align-items:center; gap:3px; padding:5px 7px;
  background:var(--panel); border-bottom:1px solid var(--border); flex-shrink:0; flex-wrap:wrap;
}
.scene-btn {
  background:var(--bg3); border:1px solid var(--border); color:var(--text2);
  border-radius:6px; padding:4px 10px; font:12px 'Sora',sans-serif; cursor:pointer;
  transition:all 0.12s; white-space:nowrap;
}
.scene-btn:hover { border-color:var(--accent2); color:var(--text); }
.scene-btn.active { background:#00e5ff18; border-color:var(--accent2); color:var(--accent2); }
.scene-divider { width:1px; height:20px; background:var(--border); margin:0 3px; }
#scene-main { flex:1; display:flex; overflow:hidden; }
#scene-viewport { flex:1; position:relative; background:#0a0a12; }
#scene-canvas { display:block; width:100%; height:100%; }
.scene-overlay {
  position:absolute; bottom:10px; left:10px; display:flex; gap:4px;
}
.view-btn {
  background:rgba(12,12,22,0.75); border:1px solid var(--border);
  color:var(--text2); border-radius:5px; padding:3px 9px;
  font:11px 'Sora',sans-serif; cursor:pointer; backdrop-filter:blur(4px);
  transition:all 0.12s;
}
.view-btn:hover, .view-btn.active { border-color:var(--accent2); color:var(--accent2); background:rgba(0,229,255,0.08); }
#scene-stats {
  position:absolute; top:8px; right:8px;
  background:rgba(10,10,20,0.7); border:1px solid var(--border);
  border-radius:6px; padding:4px 10px; font-size:10px; color:var(--text2);
  backdrop-filter:blur(4px);
}
#scene-props-panel {
  width:190px; background:var(--panel); border-left:1px solid var(--border);
  overflow-y:auto; flex-shrink:0;
}

/* ‚ïê‚ïê‚ïê ASSETS TAB ‚ïê‚ïê‚ïê */
#tab-assets { display:none; }
#tab-assets.active { display:flex; overflow:hidden; flex:1; }
#assets-inner { flex:1; overflow-y:auto; padding:12px; display:flex; flex-direction:column; gap:12px; }
#asset-drop-zone {
  border:2px dashed var(--border2); border-radius:10px; padding:28px;
  text-align:center; cursor:pointer; color:var(--text2); transition:all 0.2s;
}
#asset-drop-zone:hover, #asset-drop-zone.over { border-color:var(--accent); color:var(--text); background:#6c4fff08; }
#asset-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(86px,1fr)); gap:8px; }
.asset-card {
  background:var(--panel); border:1px solid var(--border); border-radius:8px;
  padding:8px; text-align:center; cursor:pointer; transition:all 0.12s; position:relative;
}
.asset-card:hover { border-color:var(--accent); }
.asset-thumb { font-size:30px; margin-bottom:4px; display:flex; align-items:center; justify-content:center; height:50px; overflow:hidden; }
.asset-thumb img { max-width:100%; max-height:100%; object-fit:contain; border-radius:4px; }
.asset-name { font-size:10px; color:var(--text2); word-break:break-all; }
.asset-type-badge { font-size:9px; color:var(--text3); margin-top:2px; }

/* ‚ïê‚ïê‚ïê RIGHT PANEL ‚ïê‚ïê‚ïê */
#right-panel {
  background:var(--panel); border-left:1px solid var(--border);
  display:flex; flex-direction:column; overflow:hidden;
}
#preview-header {
  display:flex; align-items:center; gap:6px; padding:6px 10px;
  border-bottom:1px solid var(--border); flex-shrink:0;
}
.preview-label { font-size:10px; color:var(--text2); font-weight:600; letter-spacing:0.5px; text-transform:uppercase; flex:1; }
#preview-wrap { flex:1; position:relative; min-height:0; }
#preview-frame { width:100%; height:100%; border:none; background:#000; display:block; }
#preview-cover {
  position:absolute; inset:0; background:var(--bg);
  display:flex; flex-direction:column; align-items:center; justify-content:center; gap:10px;
}
.cover-icon { font-size:44px; opacity:0.2; }
.cover-text { font-size:12px; color:var(--text2); opacity:0.5; }
#console-wrap { height:165px; border-top:1px solid var(--border); display:flex; flex-direction:column; flex-shrink:0; }
#console-bar { display:flex; align-items:center; padding:4px 8px; border-bottom:1px solid var(--border); flex-shrink:0; }
.console-label { font-size:10px; font-weight:600; color:var(--text2); text-transform:uppercase; letter-spacing:0.5px; flex:1; }
#console-out { flex:1; overflow-y:auto; padding:3px; font:11px/1.55 'JetBrains Mono',monospace; }
.cline { display:flex; gap:6px; padding:1px 5px; border-radius:3px; }
.ctime { color:var(--text3); flex-shrink:0; font-size:10px; }
.cmsg { flex:1; }
.cmsg.info { color:var(--text2); }
.cmsg.success { color:var(--green); }
.cmsg.error { color:var(--red); }
.cmsg.warn { color:var(--yellow); }

/* ‚ïê‚ïê‚ïê MODALS ‚ïê‚ïê‚ïê */
#modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:500; display:none; backdrop-filter:blur(3px); }
#modal-backdrop.show { display:block; }
.modal {
  position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
  background:var(--panel); border:1px solid var(--border2); border-radius:14px;
  z-index:600; display:none; min-width:360px; max-width:540px; width:90%;
  box-shadow:0 30px 80px rgba(0,0,0,.6);
}
.modal.show { display:block; }
.modal-head { padding:18px 22px 14px; border-bottom:1px solid var(--border); font:600 15px 'Sora',sans-serif; }
.modal-body { padding:16px 22px; }
.modal-foot { padding:12px 22px; border-top:1px solid var(--border); display:flex; gap:8px; justify-content:flex-end; }
.mbtn { background:var(--bg3); border:1px solid var(--border); color:var(--text2); border-radius:7px; padding:7px 16px; cursor:pointer; font:12px 'Sora',sans-serif; transition:all 0.12s; }
.mbtn:hover { border-color:var(--accent); color:var(--text); }
.mbtn.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
.mbtn.primary:hover { background:#5a3fe0; }
.minput { width:100%; background:var(--bg3); border:1px solid var(--border); color:var(--text); border-radius:7px; padding:8px 12px; font:13px 'Sora',sans-serif; margin-bottom:10px; }
.minput:focus { outline:none; border-color:var(--accent); }
.type-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:7px; margin-top:5px; }
.type-card {
  background:var(--bg3); border:2px solid var(--border); border-radius:10px;
  padding:12px 8px; text-align:center; cursor:pointer; transition:all 0.15s;
}
.type-card:hover { border-color:var(--accent); background:#6c4fff10; }
.type-card-icon { font-size:22px; margin-bottom:5px; }
.type-card-name { font-size:10px; color:var(--text2); }

/* ‚ïê‚ïê‚ïê TUTORIALS ‚ïê‚ïê‚ïê */
#tutorial-overlay {
  position:fixed; inset:0; background:rgba(0,0,0,0.88); z-index:1000;
  display:none; align-items:center; justify-content:center; backdrop-filter:blur(5px);
}
#tutorial-overlay.show { display:flex; }
#tutorial-modal {
  background:var(--panel); border:1px solid var(--border2); border-radius:18px;
  width:min(600px,92vw); overflow:hidden; box-shadow:0 48px 96px rgba(0,0,0,.65);
}
.tut-header {
  background:linear-gradient(135deg,#6c4fff22,#00e5ff14);
  padding:26px 30px 18px; border-bottom:1px solid var(--border);
}
.tut-step-pill { display:inline-block; background:#6c4fff22; border:1px solid #6c4fff55; color:var(--accent); border-radius:20px; font:600 10px 'Sora',sans-serif; padding:3px 10px; letter-spacing:1px; text-transform:uppercase; margin-bottom:10px; }
#tut-title { font:700 22px/1.2 'Sora',sans-serif; color:var(--text); }
#tut-body { padding:22px 30px; min-height:160px; }
.tut-text { color:var(--text2); line-height:1.75; font-size:13px; margin-bottom:14px; }
.tut-callout {
  background:#6c4fff14; border:1px solid #6c4fff44; border-radius:10px;
  padding:12px 16px; margin:12px 0; font-size:12px; color:var(--text); line-height:1.7;
}
.tut-code {
  background:var(--bg); border:1px solid var(--border); border-radius:8px;
  padding:12px 14px; font:12px/1.6 'JetBrains Mono',monospace; color:var(--text2);
  overflow-x:auto; margin:10px 0;
}
.tut-nav { display:flex; align-items:center; justify-content:space-between; padding:14px 30px 22px; border-top:1px solid var(--border); }
.tut-dots { display:flex; gap:6px; }
.tut-dot { width:8px; height:8px; border-radius:50%; background:var(--border2); cursor:pointer; transition:all 0.2s; }
.tut-dot.active { background:var(--accent); width:22px; border-radius:4px; }
.tut-btn { background:var(--accent); border:none; color:#fff; border-radius:8px; padding:8px 20px; font:600 13px 'Sora',sans-serif; cursor:pointer; transition:background 0.2s; }
.tut-btn:hover { background:#5a3fe0; }
.tut-btn.skip { background:var(--bg3); color:var(--text2); }
.tut-btn.skip:hover { background:var(--bg2); }
</style>
</head>
<body>

<!-- HEADER -->
<div id="header">
  <div class="logo">Lorl <span>Studio</span></div>
  <input id="project-name" type="text" value="My Game" placeholder="Project name‚Ä¶"/>
  <button class="hbtn teal" id="btn-tutorial">üìñ Tutorial</button>
  <div class="hdr-sep"></div>
  <button class="hbtn" id="btn-undo" title="Undo (Ctrl+Z)">‚Ü© Undo</button>
  <button class="hbtn" id="btn-redo" title="Redo (Ctrl+Y)">‚Ü™ Redo</button>
  <button class="hbtn" id="btn-import" title="Import .lorlgame">‚¨Ü Import</button>
  <button class="hbtn green" id="btn-preview">‚ñ∂ Preview</button>
  <button class="hbtn" id="btn-stop" style="display:none">‚èπ Stop</button>
  <button class="hbtn purple" id="btn-export">‚¨á Export .lorlgame</button>
</div>

<!-- STUDIO BODY -->
<div id="studio">

  <!-- LEFT PANEL -->
  <div id="left-panel">
    <div class="p-head">Objects <button class="icon-btn" id="btn-add-obj" title="Add object">+</button></div>
    <div id="object-tree"></div>

    <div id="props-section">
      <div class="p-head">Properties</div>
      <div id="props-content"><div style="padding:10px;color:var(--text2);font-size:11px">Select an object</div></div>
    </div>
  </div>

  <!-- CENTER PANEL -->
  <div id="center-panel">
    <div id="tabs">
      <button class="tab-btn active" data-tab="blocks">üß© Blocks</button>
      <button class="tab-btn" data-tab="code">üíª Code</button>
      <button class="tab-btn" data-tab="scene">üßä Scene</button>
      <button class="tab-btn" data-tab="assets">üñº Assets</button>
    </div>

    <!-- BLOCKS TAB -->
    <div class="tab-panel active" id="tab-blocks">
      <div id="palette">
        <div id="palette-search-wrap">
          <input id="palette-search" type="text" placeholder="Search blocks‚Ä¶"/>
        </div>
        <div id="palette-categories"></div>
      </div>
      <div id="block-canvas-wrap">
        <div id="block-canvas"></div>
        <div id="canvas-hint">
          <div class="canvas-hint-icon">üß©</div>
          <div class="canvas-hint-text">Select an object from the left,<br>then drag blocks here to script it.</div>
        </div>
        <div id="canvas-toolbar">
          <button class="ctool" id="btn-fit">‚õ∂ Fit</button>
          <button class="ctool" id="btn-zoom-in">+</button>
          <button class="ctool" id="btn-zoom-out">‚àí</button>
          <span id="zoom-label">100%</span>
        </div>
      </div>
    </div>

    <!-- CODE TAB -->
    <div class="tab-panel" id="tab-code">
      <div id="code-sidebar">
        <div class="p-head">Scripts <button class="icon-btn" id="btn-new-script" title="New script">+</button></div>
        <div id="script-list"></div>
        <div class="sync-tip">üí° Edit blocks ‚Üí code auto-updates.<br>Click <b>‚Üî Sync</b> to update blocks from code.</div>
      </div>
      <div id="code-editor-wrap">
        <div id="code-topbar">
          <span id="code-file-label">game.js</span>
          <button class="code-action sync" id="btn-sync">‚Üî Sync Blocks</button>
          <button class="code-action" id="btn-format">Format</button>
        </div>
        <div id="code-box">
          <div id="code-lines">1</div>
          <pre id="code-highlight"></pre>
          <textarea id="code-textarea" spellcheck="false"></textarea>
        </div>
      </div>
    </div>

    <!-- SCENE TAB -->
    <div class="tab-panel" id="tab-scene">
      <div id="scene-toolbar">
        <button class="scene-btn active" data-tool="select">‚ú¶ Select</button>
        <button class="scene-btn" data-tool="move">‚ú• Move</button>
        <button class="scene-btn" data-tool="rotate">‚Üª Rotate</button>
        <button class="scene-btn" data-tool="scale">‚§¢ Scale</button>
        <div class="scene-divider"></div>
        <button class="scene-btn" data-add="cube">‚¨ú Cube</button>
        <button class="scene-btn" data-add="sphere">‚¨≠ Sphere</button>
        <button class="scene-btn" data-add="cylinder">‚¨õ Cylinder</button>
        <button class="scene-btn" data-add="plane">‚ñ¨ Plane</button>
        <button class="scene-btn" data-add="character">üßç Character</button>
        <button class="scene-btn" data-add="light">üí° Light</button>
        <button class="scene-btn" data-add="camera">üì∑ Camera</button>
        <button class="scene-btn" data-add="trigger">üî≤ Trigger</button>
      </div>
      <div id="scene-main">
        <div id="scene-viewport">
          <canvas id="scene-canvas"></canvas>
          <div class="scene-overlay">
            <button class="view-btn" data-view="persp">Persp</button>
            <button class="view-btn" data-view="top">Top</button>
            <button class="view-btn" data-view="front">Front</button>
            <button class="view-btn" data-view="right">Right</button>
          </div>
          <div id="scene-stats">Loading‚Ä¶</div>
        </div>
        <div id="scene-props-panel">
          <div class="p-head">Scene Props</div>
          <div id="scene-obj-props" style="padding:10px;color:var(--text2);font-size:11px">Click an object in the viewport</div>
        </div>
      </div>
    </div>

    <!-- ASSETS TAB -->
    <div class="tab-panel" id="tab-assets">
      <div id="assets-inner">
        <div id="asset-drop-zone">
          <div style="font-size:38px;margin-bottom:8px">üìÅ</div>
          <div style="font-size:14px;font-weight:600;margin-bottom:4px">Drop assets here or click to browse</div>
          <div style="font-size:11px">Images (PNG/JPG/WebP), Audio (MP3/OGG/WAV), Models (OBJ/GLTF/GLB)</div>
          <input type="file" id="asset-file-input" multiple accept="image/*,audio/*,.obj,.gltf,.glb" style="display:none"/>
        </div>
        <div id="asset-grid"></div>
      </div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div id="right-panel">
    <div id="preview-header">
      <span class="preview-label">Preview</span>
      <button class="icon-btn" id="btn-popout" title="Open in new tab">‚§¢</button>
    </div>
    <div id="preview-wrap">
      <div id="preview-cover">
        <div class="cover-icon">‚ñ∂</div>
        <div class="cover-text">Press ‚ñ∂ Preview to run</div>
      </div>
      <iframe id="preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>
    </div>
    <div id="console-wrap">
      <div id="console-bar">
        <span class="console-label">Console</span>
        <button class="icon-btn" id="btn-clear-console" title="Clear console">‚úï</button>
      </div>
      <div id="console-out"></div>
    </div>
  </div>
</div>

<!-- ADD OBJECT MODAL -->
<div id="modal-backdrop"></div>
<div class="modal" id="modal-add-obj">
  <div class="modal-head">Add Object</div>
  <div class="modal-body">
    <input class="minput" id="new-obj-name" type="text" placeholder="Object name (leave blank for default)"/>
    <div class="type-grid" id="type-grid">
      <div class="type-card" data-type="cube"><div class="type-card-icon">‚¨ú</div><div class="type-card-name">Cube</div></div>
      <div class="type-card" data-type="sphere"><div class="type-card-icon">‚¨≠</div><div class="type-card-name">Sphere</div></div>
      <div class="type-card" data-type="cylinder"><div class="type-card-icon">‚¨õ</div><div class="type-card-name">Cylinder</div></div>
      <div class="type-card" data-type="plane"><div class="type-card-icon">‚ñ¨</div><div class="type-card-name">Plane</div></div>
      <div class="type-card" data-type="character"><div class="type-card-icon">üßç</div><div class="type-card-name">Character</div></div>
      <div class="type-card" data-type="cone"><div class="type-card-icon">üî∫</div><div class="type-card-name">Cone</div></div>
      <div class="type-card" data-type="light"><div class="type-card-icon">üí°</div><div class="type-card-name">Light</div></div>
      <div class="type-card" data-type="camera"><div class="type-card-icon">üì∑</div><div class="type-card-name">Camera</div></div>
      <div class="type-card" data-type="trigger"><div class="type-card-icon">üî≤</div><div class="type-card-name">Trigger</div></div>
      <div class="type-card" data-type="spawn"><div class="type-card-icon">üöÄ</div><div class="type-card-name">Spawn</div></div>
      <div class="type-card" data-type="torus"><div class="type-card-icon">‚≠ï</div><div class="type-card-name">Torus</div></div>
      <div class="type-card" data-type="particle"><div class="type-card-icon">‚ú®</div><div class="type-card-name">Particles</div></div>
    </div>
  </div>
  <div class="modal-foot">
    <button class="mbtn" id="btn-cancel-obj">Cancel</button>
  </div>
</div>

<!-- TUTORIAL OVERLAY -->
<div id="tutorial-overlay">
  <div id="tutorial-modal">
    <div class="tut-header">
      <div class="tut-step-pill" id="tut-step-pill">Step 1 of 7</div>
      <div id="tut-title">Welcome to Lorl Studio!</div>
    </div>
    <div id="tut-body"></div>
    <div class="tut-nav">
      <div class="tut-dots" id="tut-dots"></div>
      <div style="display:flex;gap:8px">
        <button class="tut-btn skip" id="tut-skip">Skip</button>
        <button class="tut-btn" id="tut-next">Next ‚Üí</button>
      </div>
    </div>
  </div>
</div>

<!-- DEPS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<!-- STUDIO SCRIPTS (load order matters) -->
<script>/**
 * blockdef.js ‚Äî Complete block definitions for Lorl Studio
 */
window.BlockDefs = (() => {

  const KEY_OPTIONS = [
    'Space','Enter','Escape','Backspace','Delete','Tab',
    'ArrowUp','ArrowDown','ArrowLeft','ArrowRight',
    'KeyW','KeyA','KeyS','KeyD','KeyQ','KeyE','KeyR','KeyF','KeyG','KeyH',
    'KeyI','KeyJ','KeyK','KeyL','KeyM','KeyN','KeyO','KeyP',
    'KeyT','KeyU','KeyV','KeyX','KeyY','KeyZ',
    'Digit0','Digit1','Digit2','Digit3','Digit4',
    'Digit5','Digit6','Digit7','Digit8','Digit9',
    'ShiftLeft','ShiftRight','ControlLeft','AltLeft',
    'F1','F2','F3','F4','F5','F6',
  ];

  const CATEGORIES = [
    {
      id: 'events', name: 'Events', color: '#f59e0b', icon: '‚ö°',
      blocks: [
        { id: 'on_start',       label: 'When game starts',          icon: 'üöÄ', type: 'hat',   fields: [] },
        { id: 'on_update',      label: 'Every frame',               icon: 'üîÑ', type: 'hat',   fields: [] },
        { id: 'on_keydown',     label: 'When key pressed',          icon: '‚å®Ô∏è', type: 'hat',   fields: [{ type: 'key', name: 'key', default: 'Space' }] },
        { id: 'on_keyup',       label: 'When key released',         icon: '‚å®Ô∏è', type: 'hat',   fields: [{ type: 'key', name: 'key', default: 'Space' }] },
        { id: 'on_click',       label: 'When this clicked',         icon: 'üñ±Ô∏è', type: 'hat',   fields: [] },
        { id: 'on_collide',     label: 'On collision with tag',     icon: 'üí•', type: 'hat',   fields: [{ type: 'text', name: 'tag', default: 'Wall' }] },
        { id: 'on_trigger',     label: 'On trigger enter',          icon: 'üî≤', type: 'hat',   fields: [{ type: 'text', name: 'tag', default: 'Zone' }] },
        { id: 'on_message',     label: 'When I receive message',    icon: 'üì®', type: 'hat',   fields: [{ type: 'text', name: 'msg', default: 'hit' }] },
        { id: 'on_timer',       label: 'Every N seconds (repeat)',  icon: '‚è±Ô∏è', type: 'hat',   fields: [{ type: 'number', name: 'sec', default: '1' }] },
        { id: 'on_player_join', label: 'When player joins',         icon: 'üëã', type: 'hat',   fields: [] },
        { id: 'on_player_leave','label': 'When player leaves',      icon: 'üö™', type: 'hat',   fields: [] },
        { id: 'broadcast',      label: 'Broadcast message',         icon: 'üì¢', type: 'stack', fields: [{ type: 'text', name: 'msg', default: 'hit' }] },
        { id: 'broadcast_all',  label: 'Broadcast to all players',  icon: 'üì°', type: 'stack', fields: [{ type: 'text', name: 'msg', default: 'hit' }] },
      ]
    },
    {
      id: 'control', name: 'Control', color: '#8b5cf6', icon: 'üîÄ',
      blocks: [
        { id: 'wait',       label: 'Wait seconds',        icon: '‚è≥', type: 'stack', fields: [{ type: 'number', name: 'sec', default: '1' }] },
        { id: 'wait_frames',label: 'Wait N frames',        icon: '‚è≥', type: 'stack', fields: [{ type: 'number', name: 'n', default: '1' }] },
        { id: 'repeat',     label: 'Repeat',               icon: 'üîÅ', type: 'c',    fields: [{ type: 'number', name: 'n', default: '10' }] },
        { id: 'forever',    label: 'Forever',              icon: '‚ôæÔ∏è', type: 'c',    fields: [] },
        { id: 'if',         label: 'If',                   icon: '‚ùì', type: 'c',    fields: [{ type: 'text', name: 'cond', default: 'true' }] },
        { id: 'if_else',    label: 'If / Else',            icon: '‚ùì', type: 'c2',   fields: [{ type: 'text', name: 'cond', default: 'true' }] },
        { id: 'while',      label: 'While',                icon: 'üîÑ', type: 'c',    fields: [{ type: 'text', name: 'cond', default: 'true' }] },
        { id: 'break',      label: 'Break loop',           icon: '‚õî', type: 'stack', fields: [] },
        { id: 'stop_all',   label: 'Stop all scripts',     icon: 'üõë', type: 'stack', fields: [] },
        { id: 'def_func',   label: 'Define function',      icon: 'üìù', type: 'hat',  fields: [{ type: 'text', name: 'name', default: 'myFunc' }] },
        { id: 'call_func',  label: 'Call function',        icon: 'üìû', type: 'stack', fields: [{ type: 'text', name: 'name', default: 'myFunc' }] },
        { id: 'return',     label: 'Return value',         icon: '‚Ü©Ô∏è', type: 'stack', fields: [{ type: 'text', name: 'val', default: '0' }] },
      ]
    },
    {
      id: 'motion', name: 'Motion', color: '#06b6d4', icon: 'üèÉ',
      blocks: [
        { id: 'move_forward', label: 'Move forward by',      icon: '‚û°Ô∏è', type: 'stack', fields: [{ type: 'number', name: 'dist', default: '1' }] },
        { id: 'set_pos',      label: 'Set position to X Y Z',icon: 'üìç', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'move_by',      label: 'Move by X Y Z',        icon: '‚ÜóÔ∏è', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'set_rot',      label: 'Set rotation X Y Z',   icon: 'üîÑ', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'rotate_by',    label: 'Rotate by X Y Z',      icon: 'üîÉ', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '90' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'look_at',      label: 'Look at object',       icon: 'üëÅÔ∏è', type: 'stack', fields: [{ type: 'text', name: 'obj', default: 'Player' }] },
        { id: 'look_at_pos',  label: 'Look at X Y Z',        icon: 'üëÅÔ∏è', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'glide_to',     label: 'Glide to X Y Z in secs', icon: '‚úàÔ∏è', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }, { type: 'number', name: 'sec', default: '1' }] },
        { id: 'set_speed',    label: 'Set speed',             icon: 'üí®', type: 'stack', fields: [{ type: 'number', name: 'spd', default: '5' }] },
        { id: 'get_x',        label: 'X position',            icon: 'üìê', type: 'value', fields: [] },
        { id: 'get_y',        label: 'Y position',            icon: 'üìê', type: 'value', fields: [] },
        { id: 'get_z',        label: 'Z position',            icon: 'üìê', type: 'value', fields: [] },
        { id: 'distance_to',  label: 'Distance to object',    icon: 'üìè', type: 'value', fields: [{ type: 'text', name: 'obj', default: 'Player' }] },
      ]
    },
    {
      id: 'physics', name: 'Physics', color: '#10b981', icon: '‚öõÔ∏è',
      blocks: [
        { id: 'enable_physics', label: 'Enable physics',       icon: '‚öõÔ∏è', type: 'stack', fields: [] },
        { id: 'disable_physics',label: 'Disable physics',      icon: 'üö´', type: 'stack', fields: [] },
        { id: 'jump',           label: 'Jump with force',      icon: '‚¨ÜÔ∏è', type: 'stack', fields: [{ type: 'number', name: 'force', default: '8' }] },
        { id: 'apply_force',    label: 'Apply force X Y Z',    icon: 'üí™', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '10' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'apply_impulse',  label: 'Apply impulse X Y Z',  icon: 'üí•', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '5' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'set_velocity',   label: 'Set velocity X Y Z',   icon: 'üèπ', type: 'stack', fields: [{ type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'set_gravity',    label: 'Set gravity',          icon: 'üåç', type: 'stack', fields: [{ type: 'number', name: 'g', default: '-20' }] },
        { id: 'set_mass',       label: 'Set mass',             icon: '‚öñÔ∏è', type: 'stack', fields: [{ type: 'number', name: 'm', default: '1' }] },
        { id: 'freeze_rotation',label: 'Freeze rotation',      icon: 'üßä', type: 'stack', fields: [] },
        { id: 'is_grounded',    label: 'Is grounded?',         icon: 'üèîÔ∏è', type: 'bool',  fields: [] },
      ]
    },
    {
      id: 'appearance', name: 'Appearance', color: '#ec4899', icon: 'üé®',
      blocks: [
        { id: 'set_color',    label: 'Set color',             icon: 'üé®', type: 'stack', fields: [{ type: 'color', name: 'color', default: '#4488ff' }] },
        { id: 'set_opacity',  label: 'Set opacity',           icon: 'üëª', type: 'stack', fields: [{ type: 'number', name: 'opacity', default: '1' }] },
        { id: 'show',         label: 'Show',                  icon: 'üëÅÔ∏è', type: 'stack', fields: [] },
        { id: 'hide',         label: 'Hide',                  icon: 'üôà', type: 'stack', fields: [] },
        { id: 'set_texture',  label: 'Set texture',           icon: 'üñºÔ∏è', type: 'stack', fields: [{ type: 'asset', name: 'tex', default: '' }] },
        { id: 'set_size',     label: 'Set size W H D',        icon: '‚§¢',  type: 'stack', fields: [{ type: 'number', name: 'w', default: '1' }, { type: 'number', name: 'h', default: '1' }, { type: 'number', name: 'd', default: '1' }] },
        { id: 'set_emissive', label: 'Set glow color',        icon: '‚ú®', type: 'stack', fields: [{ type: 'color', name: 'color', default: '#ff4400' }] },
        { id: 'say',          label: 'Say for secs',          icon: 'üí¨', type: 'stack', fields: [{ type: 'text', name: 'text', default: 'Hello!' }, { type: 'number', name: 'sec', default: '2' }] },
        { id: 'set_fog',      label: 'Set scene fog color',   icon: 'üå´Ô∏è', type: 'stack', fields: [{ type: 'color', name: 'color', default: '#101020' }, { type: 'number', name: 'density', default: '0.02' }] },
        { id: 'set_skybox',   label: 'Set sky color',         icon: 'üåÖ', type: 'stack', fields: [{ type: 'color', name: 'color', default: '#1a1a2e' }] },
        { id: 'set_shadow',   label: 'Set cast shadow',       icon: 'üåë', type: 'stack', fields: [{ type: 'select', name: 'on', options: ['true','false'], default: 'true' }] },
        { id: 'set_shape',    label: 'Change shape',          icon: 'üìê', type: 'stack', fields: [{ type: 'select', name: 'shape', options: ['cube','sphere','cylinder','cone','plane','torus'], default: 'cube' }] },
      ]
    },
    {
      id: 'sound', name: 'Sound', color: '#a855f7', icon: 'üîä',
      blocks: [
        { id: 'play_sound',  label: 'Play sound',             icon: '‚ñ∂Ô∏è', type: 'stack', fields: [{ type: 'asset', name: 'sound', default: '' }] },
        { id: 'play_music',  label: 'Play music (looped)',    icon: 'üéµ', type: 'stack', fields: [{ type: 'asset', name: 'music', default: '' }] },
        { id: 'stop_sound',  label: 'Stop sound',            icon: '‚èπÔ∏è', type: 'stack', fields: [{ type: 'asset', name: 'sound', default: '' }] },
        { id: 'stop_all_sounds','label':'Stop all sounds',   icon: 'üîá', type: 'stack', fields: [] },
        { id: 'set_volume',  label: 'Set volume 0-1',        icon: 'üîâ', type: 'stack', fields: [{ type: 'number', name: 'vol', default: '0.5' }] },
        { id: 'play_3d',     label: 'Play 3D sound at object',icon:'üîà', type: 'stack', fields: [{ type: 'asset', name: 'sound', default: '' }] },
      ]
    },
    {
      id: 'ui', name: 'UI & HUD', color: '#14b8a6', icon: 'üñ•Ô∏è',
      blocks: [
        { id: 'hud_show_text',  label: 'Show HUD text',      icon: 'üìù', type: 'stack', fields: [{ type: 'text', name: 'id', default: 'score' }, { type: 'text', name: 'text', default: 'Score: 0' }, { type: 'number', name: 'x', default: '20' }, { type: 'number', name: 'y', default: '20' }] },
        { id: 'hud_update',     label: 'Update HUD text',    icon: '‚úèÔ∏è', type: 'stack', fields: [{ type: 'text', name: 'id', default: 'score' }, { type: 'text', name: 'text', default: 'Score: 0' }] },
        { id: 'hud_hide',       label: 'Hide HUD element',   icon: 'üôà', type: 'stack', fields: [{ type: 'text', name: 'id', default: 'score' }] },
        { id: 'hud_show_img',   label: 'Show HUD image',     icon: 'üñºÔ∏è', type: 'stack', fields: [{ type: 'text', name: 'id', default: 'icon' }, { type: 'asset', name: 'img', default: '' }, { type: 'number', name: 'x', default: '20' }, { type: 'number', name: 'y', default: '20' }, { type: 'number', name: 'w', default: '64' }, { type: 'number', name: 'h', default: '64' }] },
        { id: 'show_prompt',    label: 'Show prompt dialog',  icon: 'üí¨', type: 'stack', fields: [{ type: 'text', name: 'msg', default: 'Enter name:' }, { type: 'text', name: 'var', default: 'playerName' }] },
        { id: 'show_tooltip',   label: 'Show tooltip',        icon: 'üí≠', type: 'stack', fields: [{ type: 'text', name: 'text', default: 'Press E to interact' }, { type: 'number', name: 'sec', default: '3' }] },
        { id: 'screen_flash',   label: 'Flash screen color',  icon: '‚ö°', type: 'stack', fields: [{ type: 'color', name: 'color', default: '#ffffff' }, { type: 'number', name: 'sec', default: '0.3' }] },
        { id: 'camera_shake',   label: 'Shake camera',        icon: 'üì∑', type: 'stack', fields: [{ type: 'number', name: 'intensity', default: '0.5' }, { type: 'number', name: 'sec', default: '0.4' }] },
      ]
    },
    {
      id: 'multiplayer', name: 'Multiplayer', color: '#f97316', icon: 'üåê',
      blocks: [
        { id: 'send_state',    label: 'Send my state',        icon: 'üì§', type: 'stack', fields: [{ type: 'text', name: 'data', default: '{x,y,z}' }] },
        { id: 'get_player_state','label':'Get player state',  icon: 'üì•', type: 'value', fields: [{ type: 'text', name: 'id', default: 'player1' }] },
        { id: 'get_all_players','label':'All player IDs',     icon: 'üë•', type: 'value', fields: [] },
        { id: 'get_my_id',     label: 'My player ID',         icon: 'ü™™', type: 'value', fields: [] },
        { id: 'get_my_name',   label: 'My display name',      icon: 'üìõ', type: 'value', fields: [] },
        { id: 'is_host',       label: 'Am I the host?',       icon: 'üëë', type: 'bool',  fields: [] },
        { id: 'player_count',  label: 'Number of players',    icon: '#Ô∏è‚É£', type: 'value', fields: [] },
        { id: 'rpc_call',      label: 'Call RPC on all',      icon: 'üì°', type: 'stack', fields: [{ type: 'text', name: 'func', default: 'myFunc' }, { type: 'text', name: 'args', default: '[]' }] },
      ]
    },
    {
      id: 'math', name: 'Math & Logic', color: '#64748b', icon: 'üî¢',
      blocks: [
        { id: 'math_op',   label: 'Math operation',            icon: 'üî¢', type: 'value', fields: [{ type: 'number', name: 'a', default: '0' }, { type: 'select', name: 'op', options: ['+','-','*','/','%','^'], default: '+' }, { type: 'number', name: 'b', default: '0' }] },
        { id: 'random',    label: 'Random between min max',    icon: 'üé≤', type: 'value', fields: [{ type: 'number', name: 'min', default: '0' }, { type: 'number', name: 'max', default: '10' }] },
        { id: 'abs',       label: 'Absolute value',            icon: '¬±',  type: 'value', fields: [{ type: 'number', name: 'n', default: '0' }] },
        { id: 'round',     label: 'Round',                     icon: '‚óã',  type: 'value', fields: [{ type: 'number', name: 'n', default: '0' }] },
        { id: 'floor',     label: 'Floor',                     icon: '‚åä',  type: 'value', fields: [{ type: 'number', name: 'n', default: '0' }] },
        { id: 'ceil',      label: 'Ceiling',                   icon: '‚åà',  type: 'value', fields: [{ type: 'number', name: 'n', default: '0' }] },
        { id: 'clamp',     label: 'Clamp between min max',     icon: '‚äÇ',  type: 'value', fields: [{ type: 'number', name: 'val', default: '0' }, { type: 'number', name: 'min', default: '0' }, { type: 'number', name: 'max', default: '100' }] },
        { id: 'lerp',      label: 'Lerp from to t',            icon: '„Ä∞Ô∏è', type: 'value', fields: [{ type: 'number', name: 'a', default: '0' }, { type: 'number', name: 'b', default: '1' }, { type: 'number', name: 't', default: '0.5' }] },
        { id: 'compare',   label: 'Compare',                   icon: '‚öñÔ∏è', type: 'bool',  fields: [{ type: 'number', name: 'a', default: '0' }, { type: 'select', name: 'op', options: ['==','!=','<','>','<=','>='], default: '==' }, { type: 'number', name: 'b', default: '0' }] },
        { id: 'and',       label: 'A and B',                   icon: '&&', type: 'bool',  fields: [{ type: 'text', name: 'a', default: 'true' }, { type: 'text', name: 'b', default: 'true' }] },
        { id: 'or',        label: 'A or B',                    icon: '||', type: 'bool',  fields: [{ type: 'text', name: 'a', default: 'false' }, { type: 'text', name: 'b', default: 'true' }] },
        { id: 'not',       label: 'Not',                       icon: '!',  type: 'bool',  fields: [{ type: 'text', name: 'a', default: 'false' }] },
        { id: 'sin',       label: 'Sin',                       icon: '„Äú', type: 'value', fields: [{ type: 'number', name: 'deg', default: '0' }] },
        { id: 'cos',       label: 'Cos',                       icon: '„Äú', type: 'value', fields: [{ type: 'number', name: 'deg', default: '0' }] },
      ]
    },
    {
      id: 'variables', name: 'Variables', color: '#dc2626', icon: 'üì¶',
      blocks: [
        { id: 'set_var',    label: 'Set variable',             icon: '=',  type: 'stack', fields: [{ type: 'text', name: 'name', default: 'myVar' }, { type: 'text', name: 'val', default: '0' }] },
        { id: 'change_var', label: 'Change variable by',       icon: '¬±',  type: 'stack', fields: [{ type: 'text', name: 'name', default: 'score' }, { type: 'number', name: 'by', default: '1' }] },
        { id: 'get_var',    label: 'Variable value',           icon: 'üì•', type: 'value', fields: [{ type: 'text', name: 'name', default: 'myVar' }] },
        { id: 'get_prop',   label: 'Object property',          icon: 'üîç', type: 'value', fields: [{ type: 'text', name: 'obj', default: 'Player' }, { type: 'select', name: 'prop', options: ['x','y','z','rotX','rotY','rotZ','scaleX','scaleY','scaleZ','speed','health','visible'], default: 'x' }] },
        { id: 'set_prop',   label: 'Set object property',      icon: '‚úèÔ∏è', type: 'stack', fields: [{ type: 'text', name: 'obj', default: 'Player' }, { type: 'select', name: 'prop', options: ['x','y','z','rotX','rotY','rotZ','scaleX','scaleY','scaleZ','speed','health','visible'], default: 'x' }, { type: 'text', name: 'val', default: '0' }] },
        { id: 'list_create',label: 'Create list',              icon: 'üìã', type: 'stack', fields: [{ type: 'text', name: 'name', default: 'items' }] },
        { id: 'list_add',   label: 'Add to list',              icon: '‚ûï', type: 'stack', fields: [{ type: 'text', name: 'list', default: 'items' }, { type: 'text', name: 'val', default: '0' }] },
        { id: 'list_get',   label: 'Item from list',           icon: 'üìã', type: 'value', fields: [{ type: 'text', name: 'list', default: 'items' }, { type: 'number', name: 'i', default: '0' }] },
        { id: 'list_length',label: 'Length of list',           icon: '#Ô∏è‚É£', type: 'value', fields: [{ type: 'text', name: 'list', default: 'items' }] },
      ]
    },
    {
      id: 'models', name: 'Models & Objects', color: '#7c3aed', icon: 'üßä',
      blocks: [
        { id: 'spawn_obj',    label: 'Spawn object at pos',    icon: '‚ú®', type: 'stack', fields: [{ type: 'text', name: 'name', default: 'Cube' }, { type: 'number', name: 'x', default: '0' }, { type: 'number', name: 'y', default: '0' }, { type: 'number', name: 'z', default: '0' }] },
        { id: 'destroy_self', label: 'Destroy this object',    icon: 'üí•', type: 'stack', fields: [] },
        { id: 'destroy_obj',  label: 'Destroy named object',   icon: 'üí•', type: 'stack', fields: [{ type: 'text', name: 'name', default: 'Enemy' }] },
        { id: 'clone_obj',    label: 'Clone object',           icon: 'üìã', type: 'stack', fields: [{ type: 'text', name: 'name', default: 'Enemy' }] },
        { id: 'find_obj',     label: 'Find object named',      icon: 'üîç', type: 'value', fields: [{ type: 'text', name: 'name', default: 'Coin' }] },
        { id: 'find_tag',     label: 'Find all with tag',      icon: 'üè∑Ô∏è', type: 'value', fields: [{ type: 'text', name: 'tag', default: 'Enemy' }] },
        { id: 'set_tag',      label: 'Set tag',                icon: 'üè∑Ô∏è', type: 'stack', fields: [{ type: 'text', name: 'tag', default: 'Enemy' }] },
        { id: 'load_model',   label: 'Load 3D model',          icon: 'üì¶', type: 'stack', fields: [{ type: 'asset', name: 'model', default: '' }] },
        { id: 'attach_to',    label: 'Attach to object',       icon: 'üîó', type: 'stack', fields: [{ type: 'text', name: 'parent', default: 'Player' }] },
        { id: 'detach',       label: 'Detach from parent',     icon: 'üîì', type: 'stack', fields: [] },
        { id: 'emit_particles','label':'Emit particles',       icon: '‚ú®', type: 'stack', fields: [{ type: 'select', name: 'fx', options: ['explosion','fire','smoke','sparks','stars','confetti'], default: 'explosion' }, { type: 'number', name: 'count', default: '20' }] },
        { id: 'set_camera_target','label':'Camera follow object',icon:'üì∑',type:'stack', fields: [{ type: 'text', name: 'obj', default: 'Player' }, { type: 'number', name: 'dist', default: '10' }, { type: 'number', name: 'height', default: '5' }] },
      ]
    },
    {
      id: 'advanced', name: 'Advanced', color: '#374151', icon: '‚öóÔ∏è',
      blocks: [
        { id: 'run_code',     label: 'Run JavaScript code',   icon: '{ }', type: 'stack', fields: [{ type: 'textarea', name: 'code', default: 'console.log("hello")' }] },
        { id: 'http_get',     label: 'HTTP GET url',          icon: 'üåê', type: 'stack', fields: [{ type: 'text', name: 'url', default: 'https://api.example.com' }, { type: 'text', name: 'var', default: 'response' }] },
        { id: 'json_parse',   label: 'Parse JSON string',     icon: 'üìÑ', type: 'value', fields: [{ type: 'text', name: 'str', default: '{}' }] },
        { id: 'local_set',    label: 'Save to local storage', icon: 'üíæ', type: 'stack', fields: [{ type: 'text', name: 'key', default: 'save' }, { type: 'text', name: 'val', default: '0' }] },
        { id: 'local_get',    label: 'Load from local storage',icon:'üíø', type: 'value', fields: [{ type: 'text', name: 'key', default: 'save' }] },
        { id: 'print',        label: 'Print to console',      icon: 'üñ®Ô∏è', type: 'stack', fields: [{ type: 'text', name: 'msg', default: 'debug' }] },
        { id: 'alert',        label: 'Alert popup',           icon: '‚ö†Ô∏è', type: 'stack', fields: [{ type: 'text', name: 'msg', default: 'Hello!' }] },
        { id: 'custom_block', label: 'Custom code block',     icon: 'üîß', type: 'stack', fields: [{ type: 'textarea', name: 'code', default: '// custom' }] },
      ]
    },
  ];

  return { CATEGORIES, KEY_OPTIONS };
})();
</script>
<script>/**
 * scene3d.js ‚Äî Interactive 3D scene editor using Three.js
 * Features: orbit camera, object picking, transform gizmos, all object types
 */
window.Scene3D = (() => {
  let scene, camera, renderer, canvas;
  let objects3d = {};       // objId ‚Üí { root, mesh, obj, outline }
  let selectedId = null;
  let activeTool = 'select';
  let initialized = false;
  let animId = null;

  // Camera orbit state
  let azimuth = 0.6, elevation = 0.42, radius = 20;
  let isOrbiting = false, prevMx = 0, prevMy = 0;
  let isPanning = false;
  let panOrigin, panCameraOrigin;

  // Outline for selection
  let outlineMesh = null;

  function init() {
    canvas = document.getElementById('scene-canvas');
    if (!canvas) { console.warn('[Scene3D] No #scene-canvas'); return; }
    if (typeof THREE === 'undefined') { console.error('[Scene3D] Three.js not loaded'); return; }

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0e1a);
    scene.fog = new THREE.FogExp2(0x0e0e1a, 0.018);

    const w = canvas.clientWidth || 800, h = canvas.clientHeight || 600;
    camera = new THREE.PerspectiveCamera(55, w/h, 0.1, 500);
    updateCamera();

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(w, h, false);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));
    const sun = new THREE.DirectionalLight(0xfff5dd, 0.95);
    sun.position.set(14, 28, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 200;
    [-35,35,-35,35].forEach((v,i)=>{sun.shadow.camera[['left','right','top','bottom'][i]]=v;});
    sun.shadow.bias = -0.0005;
    scene.add(sun);
    scene.add(new THREE.HemisphereLight(0x6688bb, 0x443322, 0.3));

    // Grid
    const grid = new THREE.GridHelper(60, 60, 0x1a1a35, 0x13132a);
    scene.add(grid);

    // Axes helper
    scene.add(new THREE.AxesHelper(3));

    // Invisible ground plane for raycasting
    const gGeo = new THREE.PlaneGeometry(500, 500);
    const gMat = new THREE.MeshStandardMaterial({ visible: false, side: THREE.DoubleSide });
    const groundPlane = new THREE.Mesh(gGeo, gMat);
    groundPlane.rotation.x = -Math.PI/2;
    groundPlane.name = '__ground__';
    scene.add(groundPlane);

    setupInput();

    const ro = new ResizeObserver(onResize);
    if (canvas.parentElement) ro.observe(canvas.parentElement);

    animate();
    initialized = true;
  }

  function animate() {
    animId = requestAnimationFrame(animate);
    if (!renderer) return;
    renderer.render(scene, camera);
    updateStats();
  }

  function updateStats() {
    const el = document.getElementById('scene-stats');
    if (el) el.textContent = `${Object.keys(objects3d).length} objects | ${activeTool} | ${selectedId ? '‚úî ' + selectedId : 'none selected'}`;
  }

  function onResize() {
    if (!canvas || !canvas.parentElement) return;
    const w = canvas.parentElement.clientWidth, h = canvas.parentElement.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }

  function updateCamera() {
    const x = radius * Math.sin(azimuth) * Math.cos(elevation);
    const y = radius * Math.sin(elevation);
    const z = radius * Math.cos(azimuth) * Math.cos(elevation);
    camera.position.set(x, Math.max(0.1, y), z);
    camera.lookAt(0, 1, 0);
  }

  function setupInput() {
    // Orbit: right-click drag or middle-click drag
    canvas.addEventListener('mousedown', e => {
      if (e.button === 2 || e.button === 1) {
        e.preventDefault();
        if (e.shiftKey || e.button === 1) {
          isPanning = true;
          panOrigin = new THREE.Vector2(e.clientX, e.clientY);
          panCameraOrigin = camera.position.clone();
        } else {
          isOrbiting = true;
          prevMx = e.clientX; prevMy = e.clientY;
        }
      }
      if (e.button === 0) handleLeftClick(e);
    });

    document.addEventListener('mousemove', e => {
      if (isOrbiting) {
        const dx = e.clientX - prevMx, dy = e.clientY - prevMy;
        prevMx = e.clientX; prevMy = e.clientY;
        azimuth -= dx * 0.006;
        elevation = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, elevation + dy * 0.006));
        updateCamera();
      }
      if (isPanning) {
        const dx = (e.clientX - panOrigin.x) * 0.025;
        const dy = (e.clientY - panOrigin.y) * 0.025;
        // Pan along camera's local axes
        const right = new THREE.Vector3();
        const up = new THREE.Vector3(0, 1, 0);
        right.crossVectors(camera.getWorldDirection(new THREE.Vector3()), up).normalize();
        camera.position.copy(panCameraOrigin).addScaledVector(right, -dx).addScaledVector(up, dy);
      }
    });

    document.addEventListener('mouseup', () => { isOrbiting = false; isPanning = false; });

    canvas.addEventListener('wheel', e => {
      radius = Math.max(1, Math.min(120, radius + e.deltaY * 0.04));
      updateCamera();
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('contextmenu', e => e.preventDefault());
  }

  function handleLeftClick(e) {
    if (!scene || !camera) return;
    const rect = canvas.getBoundingClientRect();
    const mouse = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    // Collect all pickable meshes
    const pickable = [];
    Object.entries(objects3d).forEach(([id, entry]) => {
      if (entry.root) {
        entry.root.traverse(c => { if (c.isMesh && c.name !== '__ground__') pickable.push({ mesh: c, id }); });
      }
    });

    const meshes = pickable.map(p => p.mesh);
    const hits = raycaster.intersectObjects(meshes, false);

    if (hits.length > 0) {
      const hitMesh = hits[0].object;
      const found = pickable.find(p => p.mesh === hitMesh);
      if (found) {
        selectById(found.id);
        // Notify app
        if (window.StudioApp) StudioApp.onSceneSelect(found.id);
      }
    } else {
      clearSelection();
    }
  }

  function selectById(id) {
    if (selectedId === id) return;
    clearSelection();
    selectedId = id;
    const entry = objects3d[id];
    if (!entry || !entry.root) return;

    // Add outline effect (simple emissive highlight)
    entry.root.traverse(c => {
      if (c.isMesh && c.material) {
        c._origEmissive = c.material.emissive ? c.material.emissive.clone() : new THREE.Color(0);
        if (c.material.emissive) c.material.emissive.set(0x224488);
      }
    });
  }

  function clearSelection() {
    if (selectedId && objects3d[selectedId]) {
      objects3d[selectedId].root.traverse(c => {
        if (c.isMesh && c.material && c._origEmissive) {
          c.material.emissive.copy(c._origEmissive);
        }
      });
    }
    selectedId = null;
  }

  // ‚îÄ‚îÄ Add/Update/Remove objects ‚îÄ‚îÄ

  function addObject(obj) {
    if (!scene) return;
    removeObject(obj.id);

    const color = new THREE.Color(obj.color || '#4488ff');
    const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.65, metalness: 0.1 });
    let mesh, root;

    switch (obj.type) {
      case 'cube': {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat);
        break;
      }
      case 'sphere': {
        mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 20), mat);
        break;
      }
      case 'cylinder': {
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1, 24), mat);
        break;
      }
      case 'cone': {
        mesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 20), mat);
        break;
      }
      case 'torus': {
        mesh = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.2, 12, 32), mat);
        break;
      }
      case 'plane': {
        const pm = new THREE.MeshStandardMaterial({ color, roughness: 0.9, side: THREE.DoubleSide });
        mesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), pm);
        mesh.rotation.x = -Math.PI/2;
        break;
      }
      case 'character': {
        root = new THREE.Group();
        const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.8, 12), mat.clone());
        torso.position.y = 0.55;
        torso.castShadow = true; torso.receiveShadow = true;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 14, 10), mat.clone());
        head.position.y = 1.15;
        head.castShadow = true;
        root.add(torso); root.add(head);
        mesh = torso;
        break;
      }
      case 'light': {
        const pl = new THREE.PointLight(obj.color || '#ffffff', 1.5, 25);
        const helper = new THREE.PointLightHelper(pl, 0.5);
        root = new THREE.Group();
        root.add(pl); root.add(helper);
        mesh = helper;
        break;
      }
      case 'camera': {
        const cam = new THREE.PerspectiveCamera(60, 1.77, 0.1, 20);
        mesh = new THREE.CameraHelper(cam);
        break;
      }
      case 'trigger': {
        mesh = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshBasicMaterial({ color: 0x00ffaa, wireframe: true, transparent: true, opacity: 0.4 })
        );
        break;
      }
      case 'spawn': {
        mesh = new THREE.Mesh(
          new THREE.ConeGeometry(0.3, 0.8, 8),
          new THREE.MeshBasicMaterial({ color: 0x00ff44 })
        );
        break;
      }
      default: {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat);
      }
    }

    if (!root) root = mesh;

    root.position.set(obj.x||0, obj.y||0, obj.z||0);
    root.scale.set(obj.scaleX||1, obj.scaleY||1, obj.scaleZ||1);
    root.rotation.set((obj.rotX||0)*Math.PI/180, (obj.rotY||0)*Math.PI/180, (obj.rotZ||0)*Math.PI/180);

    if (mesh && mesh.isMesh) { mesh.castShadow = true; mesh.receiveShadow = true; }

    root.userData.objId = obj.id;
    scene.add(root);
    objects3d[obj.id] = { root, mesh, obj };
  }

  function updateObject(obj) {
    const entry = objects3d[obj.id];
    if (!entry) { addObject(obj); return; }
    const root = entry.root;
    root.position.set(obj.x||0, obj.y||0, obj.z||0);
    root.scale.set(obj.scaleX||1, obj.scaleY||1, obj.scaleZ||1);
    root.rotation.set((obj.rotX||0)*Math.PI/180, (obj.rotY||0)*Math.PI/180, (obj.rotZ||0)*Math.PI/180);
    // Update color
    root.traverse(c => {
      if (c.isMesh && c.material && c.material.color) c.material.color.set(obj.color || '#4488ff');
    });
    entry.obj = obj;
  }

  function removeObject(id) {
    const entry = objects3d[id];
    if (!entry) return;
    scene.remove(entry.root);
    delete objects3d[id];
    if (selectedId === id) clearSelection();
  }

  // ‚îÄ‚îÄ View presets ‚îÄ‚îÄ
  function setView(view) {
    switch (view) {
      case 'top':   azimuth = 0; elevation = Math.PI/2 - 0.01; radius = 20; break;
      case 'front': azimuth = 0; elevation = 0.05; radius = 20; break;
      case 'right': azimuth = Math.PI/2; elevation = 0.05; radius = 20; break;
      case 'persp': azimuth = 0.6; elevation = 0.42; radius = 20; break;
    }
    updateCamera();
  }

  function setTool(tool) {
    activeTool = tool;
    document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === tool));
  }

  function getSelectedId() { return selectedId; }
  function isInitialized() { return initialized; }

  // Force resize when tab becomes visible
  function onTabActivate() {
    setTimeout(() => {
      if (initialized) onResize();
    }, 50);
  }

  return { init, addObject, updateObject, removeObject, setView, setTool, getSelectedId, isInitialized, onTabActivate };
})();
</script>

<script>
/**
 * blockcanvas.js ‚Äî Scratch-style visual block editor
 * Features: snap-connect blocks, hat/stack/C shapes, drag from palette, zoom/pan
 */
window.BlockCanvas = (() => {
  // ‚îÄ‚îÄ State ‚îÄ‚îÄ
  const objectScripts = {}; // objId ‚Üí [ script stacks [] ]
  let currentObjId = null;
  let zoom = 1, panX = 40, panY = 40;
  let isPanning = false, panStartX = 0, panStartY = 0, panOriginX = 0, panOriginY = 0;
  let dragState = null; // { block, stackRef, offsetX, offsetY, isNew }
  let selectedBlock = null;

  // ‚îÄ‚îÄ DOM refs ‚îÄ‚îÄ
  const canvasWrap = document.getElementById('block-canvas-wrap');
  const canvas = document.getElementById('block-canvas');
  const zoomLabel = document.getElementById('zoom-label');
  const hint = document.getElementById('canvas-hint');

  // ‚îÄ‚îÄ Category colors ‚îÄ‚îÄ
  const CAT_COLORS = {};
  BlockDefs.CATEGORIES.forEach(c => CAT_COLORS[c.id] = c.color);
  function blockColor(b) { return CAT_COLORS[b.cat] || '#555'; }

  // ‚îÄ‚îÄ Transform ‚îÄ‚îÄ
  function applyTransform() {
    canvas.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
    canvas.style.transformOrigin = '0 0';
    if (zoomLabel) zoomLabel.textContent = Math.round(zoom * 100) + '%';
  }

  function screenToCanvas(sx, sy) {
    const rect = canvasWrap.getBoundingClientRect();
    return {
      x: (sx - rect.left - panX) / zoom,
      y: (sy - rect.top - panY) / zoom,
    };
  }

  // ‚îÄ‚îÄ Block definition lookup ‚îÄ‚îÄ
  function findDef(id) {
    for (const cat of BlockDefs.CATEGORIES) {
      const b = cat.blocks.find(b => b.id === id);
      if (b) return { ...b, cat: cat.id };
    }
    // Unknown ‚Üí treat as custom code block
    return { id: 'custom_block', label: 'Custom: ' + id, icon: 'üîß', type: 'stack', cat: 'advanced',
             fields: [{ type: 'textarea', name: 'code', default: `// ${id}(...)` }] };
  }

  // ‚îÄ‚îÄ Block Data Model ‚îÄ‚îÄ
  // stack = { id: uid, x, y, blocks: [blockNode] }
  // blockNode = { id: blockDefId, values: {}, children: [stack], elseBlocks: [stack], el: DOMElement }

  function makeStack(x, y, firstBlock) {
    return { _uid: genUid(), x, y, blocks: firstBlock ? [firstBlock] : [] };
  }

  function makeBlock(defId, values = {}) {
    const def = findDef(defId);
    const node = {
      _uid: genUid(),
      id: defId,
      cat: def.cat,
      values: {},
      children: [],    // inner stack for C-blocks
      elseBlocks: [],  // else branch
      el: null,
    };
    def.fields.forEach(f => {
      node.values[f.name] = values[f.name] !== undefined ? values[f.name] : f.default || '';
    });
    return node;
  }

  let _uidSeq = 0;
  function genUid() { return 'b' + (++_uidSeq); }

  // ‚îÄ‚îÄ Render a full stack ‚îÄ‚îÄ
  function renderStack(stack) {
    if (stack.el) stack.el.remove();
    const wrapper = document.createElement('div');
    wrapper.className = 'scratch-stack';
    wrapper.style.cssText = `position:absolute;left:${stack.x}px;top:${stack.y}px;cursor:default;`;
    wrapper.dataset.stackId = stack._uid;

    stack.blocks.forEach((block, idx) => {
      const el = renderBlock(block, stack, idx);
      wrapper.appendChild(el);
      block.el = el;
    });

    stack.el = wrapper;
    canvas.appendChild(wrapper);
    setupStackDrag(stack);
    return wrapper;
  }

  function renderBlock(block, stack, idx) {
    const def = findDef(block.id);
    const color = blockColor(block);
    const isHat = def.type === 'hat';
    const isC = def.type === 'c' || def.type === 'c2';
    const isValue = def.type === 'value' || def.type === 'bool';

    const el = document.createElement('div');
    el.className = 'scratch-block' + (isHat ? ' block-hat' : '') + (isC ? ' block-c' : '') + (isValue ? ' block-value' : '');
    el.dataset.blockUid = block._uid;
    el.style.setProperty('--bcolor', color);

    // ‚îÄ‚îÄ Notch/tab shapes via CSS pseudo ‚îÄ‚îÄ
    el.innerHTML = buildBlockHTML(def, block, color);

    // ‚îÄ‚îÄ C-block inner slot ‚îÄ‚îÄ
    if (isC) {
      const innerWrap = document.createElement('div');
      innerWrap.className = 'block-c-inner';
      innerWrap.dataset.slot = 'inner';

      // Render child stacks
      if (block.children && block.children.length > 0) {
        block.children.forEach(cs => {
          const childEl = renderStack(cs);
          innerWrap.appendChild(childEl);
        });
      } else {
        innerWrap.innerHTML = '<div class="c-drop-hint">Drop blocks here</div>';
      }
      el.appendChild(innerWrap);

      if (def.type === 'c2') {
        const elseLabel = document.createElement('div');
        elseLabel.className = 'block-else-label';
        elseLabel.textContent = 'else';
        el.appendChild(elseLabel);
        const elseWrap = document.createElement('div');
        elseWrap.className = 'block-c-inner';
        elseWrap.dataset.slot = 'else';
        if (block.elseBlocks && block.elseBlocks.length > 0) {
          block.elseBlocks.forEach(cs => {
            const childEl = renderStack(cs);
            elseWrap.appendChild(childEl);
          });
        } else {
          elseWrap.innerHTML = '<div class="c-drop-hint">Drop else blocks here</div>';
        }
        el.appendChild(elseWrap);
      }

      // C-block bottom cap
      const capEl = document.createElement('div');
      capEl.className = 'block-c-cap';
      capEl.style.background = color;
      el.appendChild(capEl);
    }

    // Context menu (right click)
    el.addEventListener('contextmenu', e => {
      e.preventDefault(); e.stopPropagation();
      showBlockCtxMenu(e.clientX, e.clientY, block, stack);
    });

    return el;
  }

  function buildBlockHTML(def, block, color) {
    const isHat = def.type === 'hat';
    const isC   = def.type === 'c' || def.type === 'c2';

    let html = `<div class="block-main" style="background:${color};">`;
    // Hat bump
    if (isHat) html += `<div class="hat-bump" style="background:${color};"></div>`;
    html += `<div class="block-row">`;
    html += `<span class="block-icon">${def.icon}</span>`;

    // Build label + fields inline (Scratch style)
    let labelParts = def.label.split(/\[(.*?)\]/g);
    html += `<span class="block-label">`;

    // Inline label with embedded fields
    const fieldsByName = {};
    if (def.fields) def.fields.forEach(f => fieldsByName[f.name] = f);

    // Just show label text, fields below for clarity
    html += escHtml(def.label);
    html += `</span>`;
    html += `</div>`;

    // Fields row
    if (def.fields && def.fields.length > 0) {
      html += `<div class="block-fields">`;
      def.fields.forEach(f => {
        html += `<div class="block-field-row">`;
        html += `<span class="block-field-name">${escHtml(f.name)}:</span>`;
        html += makeFieldHTML(f, block.values[f.name]);
        html += `</div>`;
      });
      html += `</div>`;
    }

    // Bottom notch (for stack blocks, C blocks)
    if (!isHat && def.type !== 'value' && def.type !== 'bool') {
      html += `<div class="block-notch-bottom" style="border-top-color:${darken(color)};"></div>`;
    }
    if (isC) {
      // C-block top notch for inner
    }

    html += `</div>`; // .block-main
    return html;
  }

  function makeFieldHTML(f, value) {
    if (f.type === 'textarea') {
      return `<textarea class="block-input block-textarea" data-field="${escHtml(f.name)}" rows="2">${escHtml(String(value ?? f.default ?? ''))}</textarea>`;
    }
    if (f.type === 'color') {
      return `<input type="color" class="block-color-input" data-field="${escHtml(f.name)}" value="${escHtml(String(value ?? f.default ?? '#ffffff'))}"/>`;
    }
    if (f.type === 'select' || f.type === 'key') {
      const opts = f.options || (f.type === 'key' ? BlockDefs.KEY_OPTIONS : []);
      let selHtml = `<select class="block-select" data-field="${escHtml(f.name)}">`;
      opts.forEach(o => {
        selHtml += `<option value="${escHtml(String(o))}" ${String(value ?? f.default) === String(o) ? 'selected' : ''}>${escHtml(String(o))}</option>`;
      });
      selHtml += `</select>`;
      return selHtml;
    }
    if (f.type === 'asset') {
      const assets = window.Assets ? window.Assets.getAssets() : [];
      let selHtml = `<select class="block-select" data-field="${escHtml(f.name)}"><option value="">-- none --</option>`;
      assets.forEach(a => {
        selHtml += `<option value="${escHtml(a.id)}" ${value === a.id ? 'selected' : ''}>${escHtml(a.name)}</option>`;
      });
      selHtml += `</select>`;
      return selHtml;
    }
    // Default: text/number input
    const type = f.type === 'number' ? 'number' : 'text';
    return `<input type="${type}" class="block-input" data-field="${escHtml(f.name)}" value="${escHtml(String(value ?? f.default ?? ''))}"/>`;
  }

  // ‚îÄ‚îÄ Attach field change listeners ‚îÄ‚îÄ
  function attachFieldListeners(el, block) {
    el.querySelectorAll('[data-field]').forEach(input => {
      input.addEventListener('change', () => {
        block.values[input.dataset.field] = input.value;
        StudioApp.markDirty();
        syncBlocksToCode();
      });
      input.addEventListener('input', () => {
        block.values[input.dataset.field] = input.value;
      });
      // Prevent drag initiation from fields
      input.addEventListener('mousedown', e => e.stopPropagation());
    });
  }

  // ‚îÄ‚îÄ Stack dragging ‚îÄ‚îÄ
  function setupStackDrag(stack) {
    const el = stack.el;
    if (!el) return;

    el.addEventListener('mousedown', e => {
      if (e.button !== 0) return;
      if (e.target.closest('[data-field], .block-input, .block-select, .block-textarea, .block-color-input')) return;
      e.preventDefault();
      e.stopPropagation();

      const cp = screenToCanvas(e.clientX, e.clientY);
      dragState = {
        stack,
        offsetX: cp.x - stack.x,
        offsetY: cp.y - stack.y,
        isNew: false,
      };
      el.style.zIndex = 100;
      el.style.opacity = '0.9';
      selectedBlock = null;
    });

    // Attach field listeners to all blocks in stack
    stack.blocks.forEach(block => {
      if (block.el) attachFieldListeners(block.el, block);
    });
  }

  // ‚îÄ‚îÄ Global mouse events ‚îÄ‚îÄ
  document.addEventListener('mousemove', e => {
    if (isPanning) {
      panX = panOriginX + (e.clientX - panStartX);
      panY = panOriginY + (e.clientY - panStartY);
      applyTransform();
      return;
    }
    if (dragState) {
      const cp = screenToCanvas(e.clientX, e.clientY);
      dragState.stack.x = cp.x - dragState.offsetX;
      dragState.stack.y = cp.y - dragState.offsetY;
      if (dragState.stack.el) {
        dragState.stack.el.style.left = dragState.stack.x + 'px';
        dragState.stack.el.style.top = dragState.stack.y + 'px';
      }
    }
  });

  document.addEventListener('mouseup', e => {
    if (isPanning) { isPanning = false; return; }
    if (dragState) {
      if (dragState.stack.el) {
        dragState.stack.el.style.zIndex = '';
        dragState.stack.el.style.opacity = '';
      }
      dragState = null;
    }
  });

  // ‚îÄ‚îÄ Canvas panning (middle/right click) ‚îÄ‚îÄ
  canvasWrap.addEventListener('mousedown', e => {
    if (e.button === 1 || e.button === 2) {
      e.preventDefault();
      isPanning = true;
      panStartX = e.clientX; panStartY = e.clientY;
      panOriginX = panX; panOriginY = panY;
    }
  });
  canvasWrap.addEventListener('contextmenu', e => e.preventDefault());
  canvasWrap.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.12 : 0.89;
    zoom = Math.max(0.25, Math.min(3, zoom * factor));
    applyTransform();
  }, { passive: false });

  // ‚îÄ‚îÄ Palette drag ‚Üí canvas drop ‚îÄ‚îÄ
  document.getElementById('palette-categories').addEventListener('dragstart', e => {
    const tpl = e.target.closest('[data-block-id]');
    if (!tpl) return;
    e.dataTransfer.setData('block-id', tpl.dataset.blockId);
    e.dataTransfer.effectAllowed = 'copy';
  });

  canvasWrap.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
  canvasWrap.addEventListener('drop', e => {
    e.preventDefault();
    const defId = e.dataTransfer.getData('block-id');
    if (!defId || !currentObjId) {
      if (!currentObjId) StudioApp.log('Select an object first to add blocks!', 'warn');
      return;
    }
    const cp = screenToCanvas(e.clientX, e.clientY);
    addBlockToCanvas(defId, cp.x, cp.y);
  });

  // ‚îÄ‚îÄ Add block to canvas ‚îÄ‚îÄ
  function addBlockToCanvas(defId, x, y, values = {}) {
    if (!currentObjId) return null;
    if (!objectScripts[currentObjId]) objectScripts[currentObjId] = [];
    const block = makeBlock(defId, values);
    const stack = makeStack(x - 90, y - 20, block);
    objectScripts[currentObjId].push(stack);
    renderStack(stack);
    hint.style.display = 'none';
    syncBlocksToCode();
    return block;
  }

  // ‚îÄ‚îÄ Context menu ‚îÄ‚îÄ
  let ctxMenu = null;
  function showBlockCtxMenu(x, y, block, stack) {
    if (ctxMenu) ctxMenu.remove();
    ctxMenu = document.createElement('div');
    ctxMenu.className = 'block-ctx-menu';
    ctxMenu.style.cssText = `position:fixed;left:${x}px;top:${y}px;z-index:9999;background:var(--bg2);border:1px solid var(--border);border-radius:8px;padding:4px;min-width:160px;box-shadow:0 8px 24px rgba(0,0,0,.5);`;

    const actions = [
      ['Duplicate', () => {
        const newBlock = makeBlock(block.id, { ...block.values });
        const newStack = makeStack(stack.x + 20, stack.y + 20, newBlock);
        objectScripts[currentObjId].push(newStack);
        renderStack(newStack);
        syncBlocksToCode();
      }],
      ['Delete block', () => {
        // Remove block from stack
        const bi = stack.blocks.indexOf(block);
        if (bi >= 0) stack.blocks.splice(bi, 1);
        if (stack.blocks.length === 0) {
          // Remove empty stack
          const si = objectScripts[currentObjId].indexOf(stack);
          if (si >= 0) objectScripts[currentObjId].splice(si, 1);
          if (stack.el) stack.el.remove();
        } else {
          rerenderStack(stack);
        }
        syncBlocksToCode();
      }],
      ['Delete stack', () => {
        const si = objectScripts[currentObjId].indexOf(stack);
        if (si >= 0) objectScripts[currentObjId].splice(si, 1);
        if (stack.el) stack.el.remove();
        syncBlocksToCode();
      }],
    ];

    actions.forEach(([label, fn]) => {
      const item = document.createElement('div');
      item.textContent = label;
      item.style.cssText = 'padding:6px 12px;cursor:pointer;border-radius:5px;font-size:12px;color:var(--text);';
      item.onmouseenter = () => item.style.background = 'var(--bg3)';
      item.onmouseleave = () => item.style.background = '';
      item.onclick = () => { fn(); ctxMenu.remove(); ctxMenu = null; };
      ctxMenu.appendChild(item);
    });

    document.body.appendChild(ctxMenu);
    setTimeout(() => {
      document.addEventListener('click', () => { if (ctxMenu) { ctxMenu.remove(); ctxMenu = null; } }, { once: true });
    }, 0);
  }

  function rerenderStack(stack) {
    const oldEl = stack.el;
    const parent = oldEl ? oldEl.parentElement : canvas;
    if (oldEl) oldEl.remove();
    renderStack(stack);
    if (parent && parent !== canvas) parent.appendChild(stack.el);
    else canvas.appendChild(stack.el);
  }

  // ‚îÄ‚îÄ Switch object ‚îÄ‚îÄ
  function switchObject(objId) {
    currentObjId = objId;
    canvas.innerHTML = '';
    if (!objId) {
      hint.style.display = 'flex';
      return;
    }
    hint.style.display = 'none';
    if (!objectScripts[objId]) objectScripts[objId] = [];
    objectScripts[objId].forEach(stack => renderStack(stack));
    if (objectScripts[objId].length === 0) hint.style.display = 'flex';
  }

  // ‚îÄ‚îÄ Serialize ‚îÄ‚îÄ
  function serializeBlock(block) {
    // Collect fresh values from DOM
    const values = { ...block.values };
    if (block.el) {
      block.el.querySelectorAll('[data-field]').forEach(inp => {
        values[inp.dataset.field] = inp.value;
      });
    }
    return {
      id: block.id,
      values,
      children: (block.children || []).map(serializeStack),
      elseBlocks: (block.elseBlocks || []).map(serializeStack),
    };
  }

  function serializeStack(stack) {
    return {
      _uid: stack._uid,
      x: stack.x,
      y: stack.y,
      blocks: (stack.blocks || []).map(serializeBlock),
    };
  }

  function serialize() {
    const out = {};
    Object.entries(objectScripts).forEach(([objId, stacks]) => {
      out[objId] = stacks.map(serializeStack);
    });
    return out;
  }

  // ‚îÄ‚îÄ Deserialize ‚îÄ‚îÄ
  function deserializeBlock(data) {
    const block = makeBlock(data.id, data.values || {});
    block._uid = data._uid || block._uid;
    block.children = (data.children || []).map(deserializeStack);
    block.elseBlocks = (data.elseBlocks || []).map(deserializeStack);
    return block;
  }

  function deserializeStack(data) {
    const stack = makeStack(data.x || 0, data.y || 0);
    stack._uid = data._uid || stack._uid;
    stack.blocks = (data.blocks || []).map(deserializeBlock);
    return stack;
  }

  function deserialize(data) {
    // Clear
    Object.keys(objectScripts).forEach(k => delete objectScripts[k]);
    Object.entries(data || {}).forEach(([objId, stacks]) => {
      objectScripts[objId] = stacks.map(deserializeStack);
    });
    if (currentObjId) switchObject(currentObjId);
  }

  // ‚îÄ‚îÄ Toolbar buttons ‚îÄ‚îÄ
  document.getElementById('btn-fit').onclick = () => {
    if (!currentObjId || !objectScripts[currentObjId] || objectScripts[currentObjId].length === 0) {
      panX = 40; panY = 40; zoom = 1;
    } else {
      const stacks = objectScripts[currentObjId];
      let minX = Infinity, minY = Infinity;
      stacks.forEach(s => { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); });
      panX = -minX * zoom + 40;
      panY = -minY * zoom + 40;
    }
    applyTransform();
  };
  document.getElementById('btn-zoom-in').onclick = () => { zoom = Math.min(3, zoom * 1.2); applyTransform(); };
  document.getElementById('btn-zoom-out').onclick = () => { zoom = Math.max(0.25, zoom / 1.2); applyTransform(); };

  applyTransform();

  // ‚îÄ‚îÄ Public API ‚îÄ‚îÄ
  function getScripts() { return objectScripts; }
  function getCurrentObjId() { return currentObjId; }

  return {
    switchObject,
    addBlockToCanvas,
    serialize,
    deserialize,
    getScripts,
    getCurrentObjId,
    rerenderStack,
    serializeBlock,
    serializeStack,
    deserializeBlock,
    deserializeStack,
  };

  // ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ
  function escHtml(s) {
    return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
  }
  function darken(hex) {
    const n = parseInt(hex.replace('#',''),16);
    const r = Math.max(0, (n>>16) - 40);
    const g = Math.max(0, ((n>>8)&0xff) - 40);
    const b = Math.max(0, (n&0xff) - 40);
    return '#' + ((r<<16)|(g<<8)|b).toString(16).padStart(6,'0');
  }
})();

// ‚îÄ‚îÄ Sync blocks ‚Üí code (called after any block change) ‚îÄ‚îÄ
function syncBlocksToCode() {
  if (typeof CodeBridge !== 'undefined') CodeBridge.blocksToCode();
}


/**
 * codegen.js ‚Äî Converts block scripts ‚Üî JavaScript
 * Also handles bi-directional sync: blocks‚Üícode and code‚Üíblocks
 */
window.CodeGen = (() => {

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  //  BLOCKS ‚Üí CODE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function generateGameJS(objects, blockScripts, customFiles, assets) {
    const parts = [];

    // Runtime preamble
    parts.push(RUNTIME_CODE());

    // Asset URL declarations
    if (assets && assets.length > 0) {
      parts.push('// Asset URLs');
      assets.forEach(a => {
        parts.push(`__assetUrls[${q(a.id)}] = ${q(a.data)};`);
        parts.push(`__assetUrls[${q(a.name)}] = ${q(a.data)};`);
      });
    }

    // Object definitions
    parts.push('\n// ‚îÄ‚îÄ Object definitions ‚îÄ‚îÄ');
    objects.forEach(obj => {
      parts.push(`__defineObject(${JSON.stringify({ ...obj })});`);
    });

    // Per-object block scripts
    parts.push('\n// ‚îÄ‚îÄ Block scripts ‚îÄ‚îÄ');
    objects.forEach(obj => {
      const stacks = blockScripts[obj.id];
      if (!stacks || stacks.length === 0) return;
      parts.push(blocksToObjectCode(obj.id, stacks));
    });

    // Custom code files
    if (customFiles && customFiles.length > 0) {
      parts.push('\n// ‚îÄ‚îÄ Custom code ‚îÄ‚îÄ');
      customFiles.forEach(file => {
        parts.push(`\n// --- ${file.name} ---`);
        parts.push(file.content || '');
      });
    }

    // Kick off
    parts.push('\n__initGame();');

    return parts.join('\n');
  }

  function blocksToObjectCode(objId, stacks) {
    const lines = [`\n// === ${objId} ===`];
    lines.push(`(function() {`);
    lines.push(`  const self = __objs[${q(objId)}]; if (!self) return;`);

    stacks.forEach(stack => {
      const code = genStack(stack, '  ');
      if (code.trim()) lines.push(code);
    });

    lines.push(`})();`);
    return lines.join('\n');
  }

  function genStack(stack, indent) {
    if (!stack || !stack.blocks || stack.blocks.length === 0) return '';
    const lines = [];

    // Hat blocks group all following stack blocks
    const hats = stack.blocks.filter(b => isHat(b));
    const nonHats = stack.blocks.filter(b => !isHat(b));

    if (hats.length > 0) {
      hats.forEach(hat => {
        lines.push(genHat(hat, nonHats, indent));
      });
    } else {
      nonHats.forEach(b => {
        lines.push(indent + genBlockLine(b, indent));
      });
    }

    return lines.join('\n');
  }

  function isHat(b) {
    const def = findDef(b.id);
    return def && def.type === 'hat';
  }

  function genHat(hat, inner, indent) {
    const id = hat.id;
    const v = (name) => hat.values[name] || '';
    const innerCode = inner.map(b => genBlockLine(b, indent + '    ')).filter(Boolean).join('\n' + indent + '    ');
    const body = innerCode || '    // ...';

    switch (id) {
      case 'on_start':
        return `${indent}__events.on('start', async function() {\n${indent}    ${body}\n${indent}});`;
      case 'on_update':
        return `${indent}__events.on('update', async function(dt) {\n${indent}    ${body}\n${indent}});`;
      case 'on_keydown':
        return `${indent}__events.on('keydown:${v('key')}', async function() {\n${indent}    ${body}\n${indent}});`;
      case 'on_keyup':
        return `${indent}__events.on('keyup:${v('key')}', async function() {\n${indent}    ${body}\n${indent}});`;
      case 'on_click':
        return `${indent}__events.on('click:' + self.id, async function() {\n${indent}    ${body}\n${indent}});`;
      case 'on_collide':
        return `${indent}__events.on('collide:' + self.id + ':${v('tag')}', async function(other) {\n${indent}    ${body}\n${indent}});`;
      case 'on_trigger':
        return `${indent}__events.on('trigger:' + self.id + ':${v('tag')}', async function(other) {\n${indent}    ${body}\n${indent}});`;
      case 'on_message':
        return `${indent}__events.on('msg:${v('msg')}', async function(data) {\n${indent}    ${body}\n${indent}});`;
      case 'on_timer':
        return `${indent}setInterval(async function() {\n${indent}    ${body}\n${indent}}, ${parseFloat(v('sec') || 1) * 1000});`;
      case 'on_player_join':
        return `${indent}__events.on('player_join', async function(player) {\n${indent}    ${body}\n${indent}});`;
      case 'on_player_leave':
        return `${indent}__events.on('player_leave', async function(player) {\n${indent}    ${body}\n${indent}});`;
      case 'def_func':
        return `${indent}async function ${v('name') || 'myFunc'}() {\n${indent}    ${body}\n${indent}}`;
      default:
        return `${indent}/* unknown hat: ${id} */\n${indent}(async function() {\n${indent}    ${body}\n${indent}})();`;
    }
  }

  function genBlockLine(block, indent) {
    const id = block.id;
    const v = (name, fallback = '0') => {
      const val = block.values[name];
      return val !== undefined && val !== '' ? val : fallback;
    };
    const vn = (name, fallback = '0') => {
      const val = v(name, fallback);
      return isNaN(val) ? val : String(parseFloat(val));
    };
    const vs = (name, fallback = '') => JSON.stringify(v(name, fallback));

    switch (id) {
      // Control
      case 'wait':         return `await __wait(${vn('sec', '1')});`;
      case 'wait_frames':  return `await __waitFrames(${vn('n', '1')});`;
      case 'repeat':       return genCBlock(block, `for(let __i=0;__i<${vn('n','10')};__i++)`, indent);
      case 'forever':      return genCBlock(block, `while(true)`, indent);
      case 'if':           return genCBlock(block, `if(${v('cond','true')})`, indent);
      case 'if_else':      return genC2Block(block, `if(${v('cond','true')})`, indent);
      case 'while':        return genCBlock(block, `while(${v('cond','true')})`, indent);
      case 'break':        return `break;`;
      case 'stop_all':     return `__events.stopAll();`;
      case 'call_func':    return `await ${v('name','myFunc')}();`;
      case 'return':       return `return ${v('val','0')};`;
      case 'broadcast':    return `__events.emit(${vs('msg','hit')});`;
      case 'broadcast_all':return `if(window.Lorl) Lorl.broadcast(${vs('msg','hit')}); else __events.emit(${vs('msg','hit')});`;

      // Motion
      case 'move_forward': return `__moveForward(self, ${vn('dist','1')});`;
      case 'set_pos':      return `__setPos(self, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'move_by':      return `__moveBy(self, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'set_rot':      return `__setRot(self, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'rotate_by':    return `__rotateBy(self, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'look_at':      return `__lookAt(self, __objs[${vs('obj','Player')}]);`;
      case 'look_at_pos':  return `__lookAtPos(self, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'glide_to':     return `await __glideTo(self, ${vn('x')}, ${vn('y')}, ${vn('z')}, ${vn('sec','1')});`;
      case 'set_speed':    return `self.speed = ${vn('spd','5')};`;
      case 'distance_to':  return `__distance(self, __objs[${vs('obj','Player')}])`;

      // Physics
      case 'enable_physics': return `__enablePhysics(self);`;
      case 'disable_physics': return `__disablePhysics(self);`;
      case 'jump':         return `__jump(self, ${vn('force','8')});`;
      case 'apply_force':  return `__applyForce(self, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'apply_impulse':return `self.velocity.x+=${vn('x')}; self.velocity.y+=${vn('y')}; self.velocity.z+=${vn('z')};`;
      case 'set_velocity': return `self.velocity.x=${vn('x')}; self.velocity.y=${vn('y')}; self.velocity.z=${vn('z')};`;
      case 'set_gravity':  return `__gravity = ${vn('g','-20')};`;
      case 'set_mass':     return `self.mass = ${vn('m','1')};`;
      case 'freeze_rotation': return `self._freezeRot = true;`;
      case 'is_grounded':  return `self._grounded`;

      // Appearance
      case 'set_color':    return `__setColor(self, ${vs('color','#4488ff')});`;
      case 'set_opacity':  return `__setOpacity(self, ${vn('opacity','1')});`;
      case 'show':         return `__setVisible(self, true);`;
      case 'hide':         return `__setVisible(self, false);`;
      case 'set_texture':  return `__setTexture(self, ${vs('tex','')});`;
      case 'set_size':     return `__setSize(self, ${vn('w','1')}, ${vn('h','1')}, ${vn('d','1')});`;
      case 'set_emissive': return `__setEmissive(self, ${vs('color','#000000')});`;
      case 'say':          return `__say(self, ${vs('text','Hello!')}, ${vn('sec','2')});`;
      case 'set_fog':      return `__setFog(${vs('color','#101020')}, ${vn('density','0.02')});`;
      case 'set_skybox':   return `__setSky(${vs('color','#1a1a2e')});`;
      case 'set_shadow':   return `if(self.mesh){self.mesh.castShadow=${v('on','true')};self.mesh.receiveShadow=${v('on','true')};}`;
      case 'set_shape':    return `__setShape(self, ${vs('shape','cube')});`;

      // Sound
      case 'play_sound':   return `__playSound(${vs('sound','')});`;
      case 'play_music':   return `__playMusic(${vs('music','')});`;
      case 'stop_sound':   return `__stopSound(${vs('sound','')});`;
      case 'stop_all_sounds': return `__stopAllSounds();`;
      case 'set_volume':   return `__setVolume(${vn('vol','0.5')});`;
      case 'play_3d':      return `__playSound3D(self, ${vs('sound','')});`;

      // UI/HUD
      case 'hud_show_text': return `__hudText(${vs('id','score')}, ${vs('text','0')}, ${vn('x','20')}, ${vn('y','20')});`;
      case 'hud_update':    return `__hudUpdate(${vs('id','score')}, ${vs('text','0')});`;
      case 'hud_hide':      return `__hudHide(${vs('id','score')});`;
      case 'hud_show_img':  return `__hudImage(${vs('id','icon')}, ${vs('img','')}, ${vn('x','20')}, ${vn('y','20')}, ${vn('w','64')}, ${vn('h','64')});`;
      case 'show_prompt':   return `__vars[${vs('var','playerName')}] = prompt(${vs('msg','Enter:')}) || '';`;
      case 'show_tooltip':  return `__tooltip(${vs('text','...')}, ${vn('sec','3')});`;
      case 'screen_flash':  return `__screenFlash(${vs('color','#ffffff')}, ${vn('sec','0.3')});`;
      case 'camera_shake':  return `__cameraShake(${vn('intensity','0.5')}, ${vn('sec','0.4')});`;

      // Multiplayer
      case 'send_state':    return `if(window.Lorl) Lorl.updateState(${v('data','{}')});`;
      case 'get_player_state': return `(window.Lorl ? Lorl.getState(${vs('id','p1')}) : {})`;
      case 'get_all_players':  return `(window.Lorl ? Lorl.getPlayers() : [])`;
      case 'get_my_id':     return `(window.Lorl ? Lorl.myId() : 'local')`;
      case 'get_my_name':   return `(window.Lorl ? Lorl.getUsername() : 'Player')`;
      case 'is_host':       return `(window.Lorl ? Lorl.isHost() : true)`;
      case 'player_count':  return `(window.Lorl ? Lorl.getPlayers().length : 1)`;
      case 'rpc_call':      return `if(window.Lorl) Lorl.rpc(${vs('func','myFunc')}, ${v('args','[]')});`;

      // Math
      case 'math_op':    return `(${v('a','0')} ${v('op','+')} ${v('b','0')})`;
      case 'random':     return `(Math.random()*(${vn('max','10')}-${vn('min','0')})+${vn('min','0')})`;
      case 'abs':        return `Math.abs(${vn('n','0')})`;
      case 'round':      return `Math.round(${vn('n','0')})`;
      case 'floor':      return `Math.floor(${vn('n','0')})`;
      case 'ceil':       return `Math.ceil(${vn('n','0')})`;
      case 'clamp':      return `Math.max(${vn('min','0')},Math.min(${vn('max','100')},${vn('val','0')}))`;
      case 'lerp':       return `(${vn('a','0')}+(${vn('b','1')}-${vn('a','0')})*${vn('t','0.5')})`;
      case 'compare':    return `(${v('a','0')} ${v('op','==')} ${v('b','0')})`;
      case 'and':        return `(${v('a','true')} && ${v('b','true')})`;
      case 'or':         return `(${v('a','false')} || ${v('b','true')})`;
      case 'not':        return `(!${v('a','false')})`;
      case 'sin':        return `Math.sin(${vn('deg','0')}*Math.PI/180)`;
      case 'cos':        return `Math.cos(${vn('deg','0')}*Math.PI/180)`;
      case 'distance_to': return `__distance(self, __objs[${vs('obj','Player')}])`;

      // Variables
      case 'set_var':    return `__vars[${vs('name','myVar')}] = ${v('val','0')};`;
      case 'change_var': return `__vars[${vs('name','score')}] = (parseFloat(__vars[${vs('name','score')}])||0) + ${vn('by','1')};`;
      case 'get_var':    return `(__vars[${vs('name','myVar')}] ?? 0)`;
      case 'get_prop':   return `(__objs[${vs('obj','Player')}]?.[${vs('prop','x')}] ?? 0)`;
      case 'set_prop':   return `if(__objs[${vs('obj','Player')}]) __objs[${vs('obj','Player')}][${vs('prop','x')}] = ${v('val','0')};`;
      case 'list_create':return `__vars[${vs('name','items')}] = [];`;
      case 'list_add':   return `(__vars[${vs('list','items')}]||[]).push(${v('val','0')});`;
      case 'list_get':   return `(__vars[${vs('list','items')}]?.[${vn('i','0')}] ?? null)`;
      case 'list_length':return `(__vars[${vs('list','items')}]?.length ?? 0)`;

      // Models
      case 'spawn_obj':    return `__spawnObj(${vs('name','Cube')}, ${vn('x')}, ${vn('y')}, ${vn('z')});`;
      case 'destroy_self': return `__destroy(self);`;
      case 'destroy_obj':  return `__destroy(__objs[${vs('name','Enemy')}]);`;
      case 'clone_obj':    return `__clone(${vs('name','Enemy')});`;
      case 'find_obj':     return `__objs[${vs('name','Coin')}]`;
      case 'find_tag':     return `Object.values(__objs).filter(o=>o.tag===${vs('tag','Enemy')})`;
      case 'set_tag':      return `self.tag = ${vs('tag','Enemy')};`;
      case 'load_model':   return `__loadModel(self, ${vs('model','')});`;
      case 'attach_to':    return `__attach(self, __objs[${vs('parent','Player')}]);`;
      case 'detach':       return `__detach(self);`;
      case 'emit_particles': return `__emitParticles(self, ${vs('fx','explosion')}, ${vn('count','20')});`;
      case 'set_camera_target': return `__followCamera(__objs[${vs('obj','Player')}], ${vn('dist','10')}, ${vn('height','5')});`;

      // Advanced
      case 'run_code':
      case 'custom_block':
        return (v('code','') || '').split('\n').join('\n' + indent);
      case 'http_get':   return `fetch(${vs('url','https://api.example.com')}).then(r=>r.json()).then(d=>{__vars[${vs('var','response')}]=d;}).catch(e=>console.error(e));`;
      case 'json_parse': return `JSON.parse(${vs('str','{}')})`;
      case 'local_set':  return `localStorage.setItem(${vs('key','save')}, JSON.stringify(${v('val','0')}));`;
      case 'local_get':  return `(JSON.parse(localStorage.getItem(${vs('key','save')}))||null)`;
      case 'print':      return `console.log(${vs('msg','debug')});`;
      case 'alert':      return `alert(${vs('msg','Hello!')});`;

      // Positional getters
      case 'get_x':      return `self.x`;
      case 'get_y':      return `self.y`;
      case 'get_z':      return `self.z`;

      default:
        // Unknown ‚Üí output as comment
        return `/* [unknown block: ${id}] */`;
    }
  }

  function genCBlock(block, header, indent) {
    const innerStacks = block.children || [];
    const inner = innerStacks.flatMap(s => s.blocks.map(b => indent + '    ' + genBlockLine(b, indent + '    '))).join('\n');
    return `${header} {\n${inner || (indent + '    // ...')}\n${indent}}`;
  }

  function genC2Block(block, header, indent) {
    const inner1 = (block.children || []).flatMap(s => s.blocks.map(b => indent + '    ' + genBlockLine(b, indent + '    '))).join('\n');
    const inner2 = (block.elseBlocks || []).flatMap(s => s.blocks.map(b => indent + '    ' + genBlockLine(b, indent + '    '))).join('\n');
    return `${header} {\n${inner1 || (indent + '    // ...')}\n${indent}} else {\n${inner2 || (indent + '    // ...')}\n${indent}}`;
  }

  function findDef(id) {
    for (const cat of BlockDefs.CATEGORIES) {
      const b = cat.blocks.find(b => b.id === id);
      if (b) return { ...b, cat: cat.id };
    }
    return { id, label: id, icon: '?', type: 'stack', cat: 'advanced', fields: [] };
  }

  function q(s) { return JSON.stringify(s); }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  //  CODE ‚Üí BLOCKS  (best-effort reverse parse)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /**
   * Parse the game.js content for a given object's section and produce block stacks.
   * Returns array of stack data objects.
   * Unrecognised patterns become 'custom_block' nodes.
   */
  function codeToBlocks(code, objId) {
    if (!code || !code.trim()) return [];

    // Extract this object's IIFE section
    const startMarker = `// === ${objId} ===`;
    const endMarker = `// === END ${objId} ===`;
    let section = code;

    if (code.includes(startMarker)) {
      const si = code.indexOf(startMarker) + startMarker.length;
      const ei = code.includes(endMarker) ? code.indexOf(endMarker) : code.length;
      section = code.slice(si, ei);
    }

    const stacks = [];
    let yOff = 40;

    // Match top-level event listeners
    const eventRe = /__events\.on\(\s*'([^']+)'\s*,\s*async\s+function\s*\([^)]*\)\s*\{([\s\S]*?)\}\s*\);/g;
    let m;
    while ((m = eventRe.exec(section)) !== null) {
      const evName = m[1];
      const body = m[2];

      let hatId = null, hatValues = {};
      if      (evName === 'start')             { hatId = 'on_start'; }
      else if (evName === 'update')             { hatId = 'on_update'; }
      else if (evName.startsWith('keydown:'))   { hatId = 'on_keydown'; hatValues = { key: evName.split(':')[1] }; }
      else if (evName.startsWith('keyup:'))     { hatId = 'on_keyup'; hatValues = { key: evName.split(':')[1] }; }
      else if (evName.startsWith('msg:'))       { hatId = 'on_message'; hatValues = { msg: evName.split(':')[1] }; }
      else if (evName === 'player_join')        { hatId = 'on_player_join'; }
      else if (evName === 'player_leave')       { hatId = 'on_player_leave'; }
      else if (evName.startsWith('click:'))     { hatId = 'on_click'; }
      else if (evName.startsWith('collide:'))   { hatId = 'on_collide'; hatValues = { tag: evName.split(':')[2] || '' }; }
      else if (evName.startsWith('trigger:'))   { hatId = 'on_trigger'; hatValues = { tag: evName.split(':')[2] || '' }; }

      const blocks = [];
      if (hatId) {
        blocks.push({ id: hatId, values: hatValues, children: [], elseBlocks: [] });
      }

      // Parse body lines
      parseBodyLines(body.trim().split('\n'), blocks);

      if (blocks.length > 0) {
        stacks.push({ x: 40, y: yOff, blocks });
        yOff += Math.max(120, blocks.length * 52 + 60);
      }
    }

    // Match setInterval (on_timer)
    const timerRe = /setInterval\(\s*async\s+function\s*\(\)\s*\{([\s\S]*?)\}\s*,\s*([\d.]+)\s*\);/g;
    while ((m = timerRe.exec(section)) !== null) {
      const body = m[1];
      const ms = parseFloat(m[2]);
      const sec = (ms / 1000).toFixed(1);
      const blocks = [{ id: 'on_timer', values: { sec }, children: [], elseBlocks: [] }];
      parseBodyLines(body.trim().split('\n'), blocks);
      stacks.push({ x: 40 + stacks.length * 220, y: yOff, blocks });
      yOff += 120;
    }

    // Match function definitions
    const funcRe = /async\s+function\s+(\w+)\s*\(\)\s*\{([\s\S]*?)\n\}/g;
    while ((m = funcRe.exec(section)) !== null) {
      const name = m[1];
      const body = m[2];
      const blocks = [{ id: 'def_func', values: { name }, children: [], elseBlocks: [] }];
      parseBodyLines(body.trim().split('\n'), blocks);
      stacks.push({ x: 40 + stacks.length * 220, y: yOff + 200, blocks });
    }

    // Remaining unknown code goes into custom code blocks
    const stripped = section
      .replace(eventRe, '')
      .replace(timerRe, '')
      .replace(funcRe, '')
      .replace(/\/\/ ===.*?===/g, '')
      .replace(/\(function\(\)[\s\S]*?\}\)\(\);/g, '')
      .replace(/const self = .*?;/g, '')
      .trim();

    if (stripped && stripped !== '(function() {' && stripped.length > 3) {
      stacks.push({
        x: 40,
        y: yOff + 40,
        blocks: [{
          id: 'custom_block',
          values: { code: stripped },
          children: [],
          elseBlocks: [],
        }]
      });
    }

    return stacks;
  }

  function parseBodyLines(lines, outBlocks) {
    lines.forEach(rawLine => {
      const line = rawLine.trim();
      if (!line || line.startsWith('//') || line === '{' || line === '}') return;

      const block = lineToBlock(line);
      if (block) outBlocks.push(block);
    });
  }

  function lineToBlock(line) {
    // Try to match known patterns
    const patterns = [
      // Motion
      [/^await __wait\((.+)\);$/, (m) => ({ id:'wait', values:{ sec:m[1] } })],
      [/^__setPos\(self,\s*(.+),\s*(.+),\s*(.+)\);$/, (m) => ({ id:'set_pos', values:{x:m[1],y:m[2],z:m[3]} })],
      [/^__moveBy\(self,\s*(.+),\s*(.+),\s*(.+)\);$/, (m) => ({ id:'move_by', values:{x:m[1],y:m[2],z:m[3]} })],
      [/^__moveForward\(self,\s*(.+)\);$/, (m) => ({ id:'move_forward', values:{dist:m[1]} })],
      [/^__setRot\(self,\s*(.+),\s*(.+),\s*(.+)\);$/, (m) => ({ id:'set_rot', values:{x:m[1],y:m[2],z:m[3]} })],
      [/^__rotateBy\(self,\s*(.+),\s*(.+),\s*(.+)\);$/, (m) => ({ id:'rotate_by', values:{x:m[1],y:m[2],z:m[3]} })],
      [/^self\.speed\s*=\s*(.+);$/, (m) => ({ id:'set_speed', values:{spd:m[1]} })],
      // Physics
      [/^__enablePhysics\(self\);$/, () => ({ id:'enable_physics', values:{} })],
      [/^__disablePhysics\(self\);$/, () => ({ id:'disable_physics', values:{} })],
      [/^__jump\(self,\s*(.+)\);$/, (m) => ({ id:'jump', values:{force:m[1]} })],
      [/^__applyForce\(self,\s*(.+),\s*(.+),\s*(.+)\);$/, (m) => ({ id:'apply_force', values:{x:m[1],y:m[2],z:m[3]} })],
      [/^__gravity\s*=\s*(.+);$/, (m) => ({ id:'set_gravity', values:{g:m[1]} })],
      [/^self\.mass\s*=\s*(.+);$/, (m) => ({ id:'set_mass', values:{m:m[1]} })],
      [/^self\._freezeRot\s*=\s*true;$/, () => ({ id:'freeze_rotation', values:{} })],
      // Appearance
      [/^__setColor\(self,\s*"(.+)"\);$/, (m) => ({ id:'set_color', values:{color:m[1]} })],
      [/^__setOpacity\(self,\s*(.+)\);$/, (m) => ({ id:'set_opacity', values:{opacity:m[1]} })],
      [/^__setVisible\(self,\s*true\);$/, () => ({ id:'show', values:{} })],
      [/^__setVisible\(self,\s*false\);$/, () => ({ id:'hide', values:{} })],
      [/^__setSize\(self,\s*(.+),\s*(.+),\s*(.+)\);$/, (m) => ({ id:'set_size', values:{w:m[1],h:m[2],d:m[3]} })],
      [/^__say\(self,\s*"(.+)",\s*(.+)\);$/, (m) => ({ id:'say', values:{text:m[1],sec:m[2]} })],
      // Variables
      [/^__vars\["(.+)"\]\s*=\s*(.+);$/, (m) => ({ id:'set_var', values:{name:m[1],val:m[2]} })],
      [/^__vars\['(.+)'\]\s*=\s*\(parseFloat.*?\)\s*\+\s*(.+);$/, (m) => ({ id:'change_var', values:{name:m[1],by:m[2]} })],
      // Sound
      [/^__playSound\("(.+)"\);$/, (m) => ({ id:'play_sound', values:{sound:m[1]} })],
      [/^__stopAllSounds\(\);$/, () => ({ id:'stop_all_sounds', values:{} })],
      // UI
      [/^__hudText\("(.+)",\s*"(.+)",\s*(.+),\s*(.+)\);$/, (m) => ({ id:'hud_show_text', values:{id:m[1],text:m[2],x:m[3],y:m[4]} })],
      [/^__hudUpdate\("(.+)",\s*"(.+)"\);$/, (m) => ({ id:'hud_update', values:{id:m[1],text:m[2]} })],
      // Control
      [/^break;$/, () => ({ id:'break', values:{} })],
      [/^__events\.stopAll\(\);$/, () => ({ id:'stop_all', values:{} })],
      [/^await (\w+)\(\);$/, (m) => ({ id:'call_func', values:{name:m[1]} })],
      [/^return (.+);$/, (m) => ({ id:'return', values:{val:m[1]} })],
      [/^console\.log\((.+)\);$/, (m) => ({ id:'print', values:{msg:m[1].replace(/^"|"$/g,'')} })],
    ];

    for (const [re, fn] of patterns) {
      const match = line.match(re);
      if (match) {
        const result = fn(match.slice(1));
        return { ...result, children: [], elseBlocks: [] };
      }
    }

    // Fallback: custom code block
    return { id: 'custom_block', values: { code: line }, children: [], elseBlocks: [] };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  //  GAME RUNTIME (injected into preview/export)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function RUNTIME_CODE() {
    return `
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LORL GAME RUNTIME v2
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
'use strict';

window.__objs = {};
window.__vars = {};
window.__assetUrls = window.__assetUrls || {};
window.__gravity = -20;
window.__scene = null;
window.__camera = null;
window.__renderer = null;
window.__cameraTarget = null;
window.__cameraOffset = new THREE.Vector3(0, 5, 10);
window.__running = false;
window.__clock = { last: 0 };
window.__hudEls = {};
window.__sounds = {};
window.__musicNodes = {};
window.__audioCtx = null;

// ‚îÄ‚îÄ Event system ‚îÄ‚îÄ
window.__events = (() => {
  const listeners = {};
  return {
    on(ev, fn) { (listeners[ev] = listeners[ev] || []).push(fn); },
    off(ev, fn) { if(listeners[ev]) listeners[ev] = listeners[ev].filter(f=>f!==fn); },
    emit(ev, ...args) {
      (listeners[ev]||[]).slice().forEach(fn => { try { fn(...args); } catch(e) { console.error('[lorl]', ev, e); } });
    },
    stopAll() { Object.keys(listeners).forEach(k => listeners[k] = []); },
  };
})();

// ‚îÄ‚îÄ Timing helpers ‚îÄ‚îÄ
function __wait(sec) { return new Promise(r => setTimeout(r, sec * 1000)); }
function __waitFrames(n) {
  return new Promise(r => { let c = 0; const f = () => { if(++c >= n) r(); else requestAnimationFrame(f); }; requestAnimationFrame(f); });
}

// ‚îÄ‚îÄ Object definition ‚îÄ‚îÄ
function __defineObject(data) {
  window.__objs[data.id] = {
    ...data,
    velocity: { x:0, y:0, z:0 },
    _grounded: false,
    _freezeRot: false,
    mesh: null,
    tag: data.tag || '',
  };
}

// ‚îÄ‚îÄ Create 3D mesh for an object ‚îÄ‚îÄ
function __createMesh(obj) {
  if(!window.__scene) return;
  let mesh, geo, mat, group;

  const color = new THREE.Color(obj.color || '#4488ff');
  mat = new THREE.MeshStandardMaterial({ color, roughness: 0.65, metalness: 0.1 });

  switch(obj.type) {
    case 'cube':
      geo = new THREE.BoxGeometry(1, 1, 1);
      mesh = new THREE.Mesh(geo, mat);
      break;
    case 'sphere':
      geo = new THREE.SphereGeometry(0.5, 32, 20);
      mesh = new THREE.Mesh(geo, mat);
      break;
    case 'cylinder':
      geo = new THREE.CylinderGeometry(0.5, 0.5, 1, 24);
      mesh = new THREE.Mesh(geo, mat);
      break;
    case 'cone':
      geo = new THREE.ConeGeometry(0.5, 1, 20);
      mesh = new THREE.Mesh(geo, mat);
      break;
    case 'torus':
      geo = new THREE.TorusGeometry(0.5, 0.2, 12, 32);
      mesh = new THREE.Mesh(geo, mat);
      break;
    case 'plane': {
      const planeMat = new THREE.MeshStandardMaterial({ color, roughness: 0.8, metalness: 0, side: THREE.DoubleSide });
      geo = new THREE.PlaneGeometry(1, 1);
      mesh = new THREE.Mesh(geo, planeMat);
      mesh.rotation.x = -Math.PI / 2;
      break;
    }
    case 'character': {
      group = new THREE.Group();
      const torsoG = new THREE.CylinderGeometry(0.28, 0.28, 0.8, 12);
      const torso = new THREE.Mesh(torsoG, mat.clone());
      torso.position.y = 0.55;
      const headG = new THREE.SphereGeometry(0.25, 14, 10);
      const head = new THREE.Mesh(headG, mat.clone());
      head.position.y = 1.15;
      group.add(torso);
      group.add(head);
      mesh = torso;
      break;
    }
    case 'light': {
      const pl = new THREE.PointLight(obj.color || '#ffffff', 1.5, 25);
      const helper = new THREE.PointLightHelper(pl, 0.4);
      group = new THREE.Group();
      group.add(pl); group.add(helper);
      mesh = helper;
      break;
    }
    case 'camera': {
      const camHelper = new THREE.CameraHelper(new THREE.PerspectiveCamera(60, 1.77, 0.1, 20));
      mesh = camHelper;
      break;
    }
    case 'trigger': {
      geo = new THREE.BoxGeometry(2, 2, 2);
      mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x00ffaa, wireframe: true, transparent: true, opacity: 0.4 }));
      break;
    }
    default:
      geo = new THREE.BoxGeometry(1, 1, 1);
      mesh = new THREE.Mesh(geo, mat);
  }

  const root = group || mesh;
  root.position.set(obj.x||0, obj.y||0, obj.z||0);
  root.scale.set(obj.scaleX||1, obj.scaleY||1, obj.scaleZ||1);
  root.rotation.set((obj.rotX||0)*Math.PI/180, (obj.rotY||0)*Math.PI/180, (obj.rotZ||0)*Math.PI/180);
  if(mesh && typeof mesh.castShadow !== 'undefined') { mesh.castShadow = true; mesh.receiveShadow = true; }

  window.__scene.add(root);
  obj.mesh = root;
  obj._meshRoot = root;
  obj._mat = mat;
}

// ‚îÄ‚îÄ Motion ‚îÄ‚îÄ
function __setPos(obj, x, y, z) {
  if(!obj || !obj._meshRoot) return;
  obj._meshRoot.position.set(+x, +y, +z);
  obj.x=+x; obj.y=+y; obj.z=+z;
}
function __moveBy(obj, dx, dy, dz) {
  if(!obj || !obj._meshRoot) return;
  obj._meshRoot.position.x += +dx;
  obj._meshRoot.position.y += +dy;
  obj._meshRoot.position.z += +dz;
  obj.x=obj._meshRoot.position.x; obj.y=obj._meshRoot.position.y; obj.z=obj._meshRoot.position.z;
}
function __moveForward(obj, dist) {
  if(!obj || !obj._meshRoot) return;
  const dir = new THREE.Vector3(0, 0, -dist);
  dir.applyEuler(obj._meshRoot.rotation);
  __moveBy(obj, dir.x, dir.y, dir.z);
}
function __setRot(obj, rx, ry, rz) {
  if(!obj || !obj._meshRoot) return;
  obj._meshRoot.rotation.set(+rx*Math.PI/180, +ry*Math.PI/180, +rz*Math.PI/180);
}
function __rotateBy(obj, rx, ry, rz) {
  if(!obj || !obj._meshRoot) return;
  obj._meshRoot.rotation.x += +rx*Math.PI/180;
  obj._meshRoot.rotation.y += +ry*Math.PI/180;
  obj._meshRoot.rotation.z += +rz*Math.PI/180;
}
function __lookAt(obj, target) {
  if(!obj || !obj._meshRoot || !target || !target._meshRoot) return;
  obj._meshRoot.lookAt(target._meshRoot.position);
}
function __lookAtPos(obj, x, y, z) {
  if(!obj || !obj._meshRoot) return;
  obj._meshRoot.lookAt(new THREE.Vector3(+x, +y, +z));
}
function __distance(a, b) {
  if(!a || !b || !a._meshRoot || !b._meshRoot) return Infinity;
  return a._meshRoot.position.distanceTo(b._meshRoot.position);
}
async function __glideTo(obj, tx, ty, tz, sec) {
  if(!obj || !obj._meshRoot) return;
  const start = obj._meshRoot.position.clone();
  const end = new THREE.Vector3(+tx, +ty, +tz);
  const t0 = performance.now();
  const dur = +sec * 1000;
  await new Promise(res => {
    function step(ts) {
      const t = Math.min(1, (ts - t0) / dur);
      const e = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
      obj._meshRoot.position.lerpVectors(start, end, e);
      obj.x=obj._meshRoot.position.x; obj.y=obj._meshRoot.position.y; obj.z=obj._meshRoot.position.z;
      if(t < 1) requestAnimationFrame(step); else res();
    }
    requestAnimationFrame(step);
  });
}

// ‚îÄ‚îÄ Physics ‚îÄ‚îÄ
function __enablePhysics(obj) { if(obj) obj.physics = true; }
function __disablePhysics(obj) { if(obj) obj.physics = false; }
function __jump(obj, force) { if(obj && obj.physics && obj._grounded) { obj.velocity.y = +force; obj._grounded = false; } }
function __applyForce(obj, fx, fy, fz) { if(obj && obj.physics) { obj.velocity.x += +fx; obj.velocity.y += +fy; obj.velocity.z += +fz; } }

// ‚îÄ‚îÄ Appearance ‚îÄ‚îÄ
function __setColor(obj, color) {
  if(!obj) return; obj.color = color;
  if(obj._mat) obj._mat.color.set(color);
  if(obj._meshRoot) obj._meshRoot.traverse(c => { if(c.isMesh && c.material && c.material.color) c.material.color.set(color); });
}
function __setOpacity(obj, v) {
  if(!obj || !obj._mat) return;
  obj._mat.transparent = +v < 1; obj._mat.opacity = Math.max(0, Math.min(1, +v));
}
function __setVisible(obj, v) { if(obj && obj._meshRoot) obj._meshRoot.visible = !!v; }
function __setSize(obj, w, h, d) {
  if(!obj || !obj._meshRoot) return;
  obj._meshRoot.scale.set(+w, +h, +d);
  obj.scaleX=+w; obj.scaleY=+h; obj.scaleZ=+d;
}
function __setEmissive(obj, color) {
  if(obj && obj._mat && obj._mat.emissive) obj._mat.emissive.set(color);
}
function __setTexture(obj, assetIdOrName) {
  const url = window.__assetUrls[assetIdOrName];
  if(!url || !obj || !obj._mat) return;
  const tex = new THREE.TextureLoader().load(url);
  obj._mat.map = tex; obj._mat.needsUpdate = true;
}
function __setShape(obj, shape) {
  // Simplified: log for now
  console.log('[Lorl] setShape:', obj?.id, shape);
}
function __say(obj, text, sec) {
  if(!obj || !obj._meshRoot) return;
  const hud = document.getElementById('hud');
  const old = document.getElementById('say_'+obj.id);
  if(old) old.remove();
  const el = document.createElement('div');
  el.id = 'say_'+obj.id;
  el.style.cssText = 'position:absolute;background:rgba(0,0,0,0.8);color:#fff;border-radius:8px;padding:6px 12px;font-size:14px;font-family:sans-serif;white-space:nowrap;pointer-events:none;';
  el.textContent = text;
  hud.appendChild(el);
  // rough screen position
  const v = obj._meshRoot.position.clone().project(window.__camera);
  el.style.left = ((v.x+1)/2*window.innerWidth)+'px';
  el.style.top  = ((-v.y+1)/2*window.innerHeight-60)+'px';
  setTimeout(() => el.remove(), +sec * 1000);
}
function __setFog(color, density) {
  if(window.__scene) window.__scene.fog = new THREE.FogExp2(new THREE.Color(color), +density);
}
function __setSky(color) {
  if(window.__scene) window.__scene.background = new THREE.Color(color);
}

// ‚îÄ‚îÄ Sound ‚îÄ‚îÄ
function __playSound(assetIdOrName) {
  const url = window.__assetUrls[assetIdOrName] || assetIdOrName;
  if(!url) return;
  try { new Audio(url).play().catch(()=>{}); } catch(e) {}
}
function __playMusic(assetIdOrName) {
  const url = window.__assetUrls[assetIdOrName] || assetIdOrName;
  if(!url) return;
  const audio = new Audio(url);
  audio.loop = true;
  audio.volume = 0.5;
  audio.play().catch(()=>{});
  window.__musicNodes[assetIdOrName] = audio;
}
function __stopSound(id) { if(window.__musicNodes[id]) { window.__musicNodes[id].pause(); delete window.__musicNodes[id]; } }
function __stopAllSounds() { Object.values(window.__musicNodes).forEach(a => a.pause()); window.__musicNodes = {}; }
function __setVolume(v) { Object.values(window.__musicNodes).forEach(a => a.volume = Math.max(0,Math.min(1,+v))); }
function __playSound3D(obj, id) { __playSound(id); /* spatial audio TODO */ }

// ‚îÄ‚îÄ HUD ‚îÄ‚îÄ
function __hudText(id, text, x, y) {
  const hud = document.getElementById('hud');
  let el = window.__hudEls[id] || document.getElementById('hud_'+id);
  if(!el) {
    el = document.createElement('div');
    el.id = 'hud_'+id;
    el.style.cssText = 'position:absolute;font-family:sans-serif;font-size:22px;font-weight:700;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.6);pointer-events:none;';
    hud.appendChild(el);
    window.__hudEls[id] = el;
  }
  el.textContent = text;
  el.style.left = +x+'px';
  el.style.top = +y+'px';
  el.style.display = 'block';
}
function __hudUpdate(id, text) {
  const el = window.__hudEls[id] || document.getElementById('hud_'+id);
  if(el) el.textContent = text;
}
function __hudHide(id) {
  const el = window.__hudEls[id] || document.getElementById('hud_'+id);
  if(el) el.style.display = 'none';
}
function __hudImage(id, assetId, x, y, w, h) {
  const hud = document.getElementById('hud');
  let el = window.__hudEls[id+'_img'];
  if(!el) { el = document.createElement('img'); el.id = 'hud_img_'+id; hud.appendChild(el); window.__hudEls[id+'_img'] = el; }
  const url = window.__assetUrls[assetId] || assetId;
  el.src = url; el.style.cssText = 'position:absolute;left:${+x}px;top:${+y}px;width:${+w}px;height:${+h}px;pointer-events:none;';
}
function __tooltip(text, sec) {
  __hudText('__tooltip__', text, window.innerWidth/2-100, window.innerHeight-80);
  setTimeout(() => __hudHide('__tooltip__'), +sec*1000);
}
function __screenFlash(color, sec) {
  const hud = document.getElementById('hud');
  const el = document.createElement('div');
  el.style.cssText = \`position:absolute;inset:0;background:\${color};opacity:0.6;pointer-events:none;transition:opacity \${+sec}s;\`;
  hud.appendChild(el);
  requestAnimationFrame(() => { el.style.opacity = '0'; });
  setTimeout(() => el.remove(), +sec*1000+100);
}
function __cameraShake(intensity, sec) {
  if(!window.__camera) return;
  const orig = window.__camera.position.clone();
  const end = performance.now() + +sec*1000;
  function shake() {
    if(performance.now() > end) { window.__camera.position.copy(orig); return; }
    window.__camera.position.x = orig.x + (Math.random()-0.5)*2*+intensity;
    window.__camera.position.y = orig.y + (Math.random()-0.5)*2*+intensity;
    requestAnimationFrame(shake);
  }
  requestAnimationFrame(shake);
}

// ‚îÄ‚îÄ Object management ‚îÄ‚îÄ
function __spawnObj(name, x, y, z) {
  const template = Object.values(window.__objs).find(o => o.name === name || o.id === name);
  if(!template) { console.warn('[lorl] No object template:', name); return; }
  const clone = { ...template, id: template.id + '_clone_' + Date.now(), x:+x, y:+y, z:+z, mesh:null, _meshRoot:null, velocity:{x:0,y:0,z:0} };
  window.__objs[clone.id] = clone;
  __createMesh(clone);
  return clone;
}
function __destroy(obj) {
  if(!obj) return;
  if(obj._meshRoot) window.__scene.remove(obj._meshRoot);
  delete window.__objs[obj.id];
}
function __clone(name) { return __spawnObj(name, 0, 0, 0); }
function __attach(child, parent) {
  if(!child || !child._meshRoot || !parent || !parent._meshRoot) return;
  parent._meshRoot.add(child._meshRoot);
}
function __detach(child) {
  if(!child || !child._meshRoot) return;
  window.__scene.attach(child._meshRoot);
}
function __emitParticles(obj, fx, count) {
  if(!obj || !obj._meshRoot || !window.__scene) return;
  const pos = obj._meshRoot.position.clone();
  for(let i=0;i<Math.min(+count,50);i++) {
    const g = new THREE.SphereGeometry(0.05+Math.random()*0.08, 4, 4);
    const m = new THREE.MeshBasicMaterial({ color: fx==='fire'?0xff4400:fx==='smoke'?0x888888:0xffffff });
    const mesh = new THREE.Mesh(g, m);
    mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-.5)*0.5,(Math.random()-.5)*0.5,(Math.random()-.5)*0.5));
    window.__scene.add(mesh);
    const v = new THREE.Vector3((Math.random()-.5)*3, Math.random()*4+1, (Math.random()-.5)*3);
    const start = performance.now();
    (function animate() {
      const t = (performance.now()-start)/1000;
      if(t>1.5){window.__scene.remove(mesh);return;}
      mesh.position.addScaledVector(v, 0.016);
      m.opacity = 1-t/1.5; m.transparent=true;
      requestAnimationFrame(animate);
    })();
  }
}
function __followCamera(target, dist, height) {
  if(!target) return;
  window.__cameraTarget = target;
  window.__cameraOffset = new THREE.Vector3(0, +height, +dist);
}
function __loadModel(obj, assetIdOrName) {
  console.log('[lorl] loadModel:', obj?.id, assetIdOrName, '(OBJ/GLTF loading requires additional setup)');
}

// ‚îÄ‚îÄ Camera collision bounds ‚îÄ‚îÄ
window._camLookAt = new THREE.Vector3();

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
function __initGame() {
  const canvas = document.getElementById('game-canvas');
  if (!canvas) { console.error('[lorl] No #game-canvas element found!'); return; }

  // Scene
  window.__scene = new THREE.Scene();
  window.__scene.background = new THREE.Color(0x0d0d1a);
  window.__scene.fog = new THREE.FogExp2(0x0d0d1a, 0.015);

  const w = window.innerWidth, h = window.innerHeight;
  window.__camera = new THREE.PerspectiveCamera(65, w/h, 0.1, 1000);
  window.__camera.position.set(0, 8, 14);
  window.__camera.lookAt(0, 1, 0);

  window.__renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  window.__renderer.setSize(w, h, false);
  window.__renderer.shadowMap.enabled = true;
  window.__renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  window.__renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
  window.__renderer.outputEncoding = THREE.sRGBEncoding || 3001;
  window.__renderer.toneMapping = THREE.ACESFilmicToneMapping;
  window.__renderer.toneMappingExposure = 1.1;

  // Lighting
  const ambient = new THREE.AmbientLight(0xffffff, 0.45);
  window.__scene.add(ambient);

  const sun = new THREE.DirectionalLight(0xfff5e0, 1.1);
  sun.position.set(15, 30, 12);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 200;
  sun.shadow.camera.left = -40;
  sun.shadow.camera.right = 40;
  sun.shadow.camera.top = 40;
  sun.shadow.camera.bottom = -40;
  sun.shadow.bias = -0.0005;
  window.__scene.add(sun);

  const rim = new THREE.HemisphereLight(0x8888ff, 0x333322, 0.35);
  window.__scene.add(rim);

  // Ground
  const gGeo = new THREE.PlaneGeometry(300, 300, 4, 4);
  const gMat = new THREE.MeshStandardMaterial({ color: 0x0d1020, roughness: 0.9 });
  const ground = new THREE.Mesh(gGeo, gMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  ground.name = '__ground__';
  window.__scene.add(ground);

  // Grid
  window.__scene.add(new THREE.GridHelper(80, 80, 0x1a1a3a, 0x111128));

  // Create all object meshes
  Object.values(window.__objs).forEach(__createMesh);

  // Input
  window._keys = {};
  window._keyJustPressed = {};
  document.addEventListener('keydown', e => {
    if(!window._keys[e.code]) {
      window._keys[e.code] = true;
      window._keyJustPressed[e.code] = true;
      window.__events.emit('keydown:' + e.code, e);
      window.__events.emit('keydown:' + e.key, e);
    }
  });
  document.addEventListener('keyup', e => {
    window._keys[e.code] = false;
    window.__events.emit('keyup:' + e.code, e);
    window.__events.emit('keyup:' + e.key, e);
  });
  document.addEventListener('click', () => {
    // Raycast for click events
    window.__events.emit('click:canvas');
  });

  // Resize
  window.addEventListener('resize', () => {
    const nw = window.innerWidth, nh = window.innerHeight;
    window.__renderer.setSize(nw, nh, false);
    window.__camera.aspect = nw/nh;
    window.__camera.updateProjectionMatrix();
  });

  // ‚îÄ‚îÄ Game loop ‚îÄ‚îÄ
  window.__running = true;
  window.__clock.last = performance.now();

  function loop(ts) {
    if (!window.__running) return;
    const dt = Math.min((ts - window.__clock.last) / 1000, 0.1);
    window.__clock.last = ts;

    // Physics
    Object.values(window.__objs).forEach(obj => {
      if (!obj.physics || !obj._meshRoot) return;

      // Gravity
      obj.velocity.y += window.__gravity * dt;

      // Integration
      obj._meshRoot.position.x += obj.velocity.x * dt;
      obj._meshRoot.position.y += obj.velocity.y * dt;
      obj._meshRoot.position.z += obj.velocity.z * dt;

      // Freeze rotation if set
      if (obj._freezeRot) { obj._meshRoot.rotation.x = 0; obj._meshRoot.rotation.z = 0; }

      // Sync object data
      obj.x = obj._meshRoot.position.x;
      obj.y = obj._meshRoot.position.y;
      obj.z = obj._meshRoot.position.z;

      // Floor collision
      const floorY = 0.5 * (obj.scaleY || 1);
      if (obj._meshRoot.position.y <= floorY) {
        obj._meshRoot.position.y = floorY;
        obj.velocity.y = 0;
        obj._grounded = true;
      } else {
        obj._grounded = false;
      }

      // Horizontal drag
      obj.velocity.x *= 0.85;
      obj.velocity.z *= 0.85;

      // Simple AABB collision detection
      Object.values(window.__objs).forEach(other => {
        if (other === obj || !other._meshRoot) return;
        const dx = obj._meshRoot.position.x - other._meshRoot.position.x;
        const dy = obj._meshRoot.position.y - other._meshRoot.position.y;
        const dz = obj._meshRoot.position.z - other._meshRoot.position.z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        const threshold = ((obj.scaleX||1) + (other.scaleX||1)) * 0.6;
        if (dist < threshold) {
          window.__events.emit('collide:' + obj.id + ':' + (other.tag || other.id));
          if (other.tag) window.__events.emit('collide:' + obj.id + ':' + other.tag);
        }
      });
    });

    // Camera follow
    if (window.__cameraTarget && window.__cameraTarget._meshRoot) {
      const tp = window.__cameraTarget._meshRoot.position;
      const targetCamPos = tp.clone().add(window.__cameraOffset);
      window.__camera.position.lerp(targetCamPos, 5 * dt);
      window._camLookAt.lerp(tp, 8 * dt);
      window.__camera.lookAt(window._camLookAt);
    }

    // Update say-bubble positions
    Object.values(window.__objs).forEach(obj => {
      if(!obj._meshRoot) return;
      const el = document.getElementById('say_'+obj.id);
      if(el) {
        const v = obj._meshRoot.position.clone().project(window.__camera);
        el.style.left = ((v.x+1)/2*window.innerWidth)+'px';
        el.style.top  = ((-v.y+1)/2*window.innerHeight-60)+'px';
      }
    });

    // Events
    window.__events.emit('update', dt);
    window._keyJustPressed = {};

    window.__renderer.render(window.__scene, window.__camera);
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // Fire start event on next tick
  requestAnimationFrame(() => {
    window.__events.emit('start');
  });
}
`;
  }

  return {
    generateGameJS,
    blocksToObjectCode,
    codeToBlocks,
    RUNTIME_CODE,
  };
})();

// ‚îÄ‚îÄ Code Bridge: keeps blocks and code in sync ‚îÄ‚îÄ
window.CodeBridge = (() => {
  // Blocks ‚Üí Code
  function blocksToCode() {
    if (typeof StudioApp === 'undefined') return;
    const scripts = BlockCanvas.serialize();
    const objId = BlockCanvas.getCurrentObjId();
    if (!objId) return;

    const stacks = scripts[objId] || [];
    const code = CodeGen.blocksToObjectCode(objId, stacks);

    // Inject into the game.js file
    const files = window.CodeEditor ? CodeEditor.getFiles() : {};
    let gameJs = files['game.js'] || '';

    const startMarker = `\n// === ${objId} ===`;
    const endMarker = `// === END ${objId} ===\n`;

    if (gameJs.includes(startMarker)) {
      const si = gameJs.indexOf(startMarker);
      const ei = gameJs.indexOf(endMarker);
      if (ei >= 0) {
        gameJs = gameJs.slice(0, si) + '\n' + code + '\n' + endMarker + gameJs.slice(ei + endMarker.length);
      } else {
        gameJs = gameJs.slice(0, si) + '\n' + code + '\n' + endMarker + gameJs.slice(si);
      }
    } else {
      gameJs += '\n' + code + '\n' + endMarker;
    }

    if (window.CodeEditor) CodeEditor.setFileContent('game.js', gameJs, true /* silent */);
  }

  // Code ‚Üí Blocks
  function codeToBlocks() {
    const objId = BlockCanvas.getCurrentObjId();
    if (!objId) return;
    const files = window.CodeEditor ? CodeEditor.getFiles() : {};
    const gameJs = files['game.js'] || '';
    const stacks = CodeGen.codeToBlocks(gameJs, objId);
    if (stacks.length > 0) {
      BlockCanvas.deserialize({ [objId]: stacks });
      StudioApp.log('Blocks updated from code ‚Üî', 'success');
    }
  }

  return { blocksToCode, codeToBlocks };
})();


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LORL STUDIO ‚Äî Main Application Logic
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ State ‚îÄ‚îÄ
let objects = [];
let selectedObjId = null;
let codeFiles = {};
let assets = [];
let history = [], histIdx = -1;
const MAX_HIST = 80;
let _objSeq = 0;

// ‚îÄ‚îÄ Utilities ‚îÄ‚îÄ
const $ = id => document.getElementById(id);
function escH(s) { return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function uid() { return 'o' + (++_objSeq) + '_' + Math.random().toString(36).slice(2,6); }
function hexDarken(hex, amount=40) {
  const n = parseInt(hex.replace('#',''),16);
  const r = Math.max(0,(n>>16)-amount), g = Math.max(0,((n>>8)&0xff)-amount), b = Math.max(0,(n&0xff)-amount);
  return '#'+((r<<16)|(g<<8)|b).toString(16).padStart(6,'0');
}

// ‚îÄ‚îÄ Stub StudioApp (for modules) ‚îÄ‚îÄ
window.StudioApp = {
  log: (m, l) => consoleLog(m, l),
  markDirty: () => {},
  onSceneSelect: (id) => selectObj(id),
};

// ‚îÄ‚îÄ Object factory ‚îÄ‚îÄ
const TYPE_ICONS = { cube:'‚¨ú',sphere:'‚¨≠',cylinder:'‚¨õ',plane:'‚ñ¨',character:'üßç',cone:'üî∫',light:'üí°',camera:'üì∑',trigger:'üî≤',spawn:'üöÄ',torus:'‚≠ï',particle:'‚ú®' };
function createObj(type, name) {
  const icon = TYPE_ICONS[type] || 'üì¶';
  const id = type + '_' + uid();
  return {
    id, type, icon,
    name: name || (type.charAt(0).toUpperCase()+type.slice(1)) + ' ' + _objSeq,
    x:0, y: type==='plane'?0:0.5, z:0,
    rotX:0, rotY:0, rotZ:0,
    scaleX:1, scaleY:1, scaleZ:1,
    color: type==='plane'?'#1e3040': type==='light'?'#ffffff': '#4488ff',
    physics: false,
    visible: true,
    speed: 5,
    mass: 1,
    health: 100,
    tag: '',
  };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TABS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let activeTab = 'blocks';
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => switchTab(btn.dataset.tab));
});
function switchTab(tab) {
  activeTab = tab;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab===tab));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.toggle('active', p.id==='tab-'+tab));

  if (tab === 'scene') {
    if (!Scene3D.isInitialized()) {
      setTimeout(() => {
        Scene3D.init();
        objects.forEach(o => Scene3D.addObject(o));
      }, 80);
    } else {
      Scene3D.onTabActivate();
    }
  }
  if (tab === 'code') {
    CodeEditor.refresh();
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  OBJECTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function addObj(type, name) {
  const obj = createObj(type, name);
  objects.push(obj);
  if (Scene3D.isInitialized()) Scene3D.addObject(obj);
  renderObjTree();
  selectObj(obj.id);
  pushHistory();
  consoleLog(`Added ${obj.name}`, 'success');
  return obj;
}

function deleteObj(id) {
  const idx = objects.findIndex(o => o.id===id);
  if (idx < 0) return;
  objects.splice(idx, 1);
  Scene3D.removeObject(id);
  if (selectedObjId === id) {
    selectedObjId = null;
    BlockCanvas.switchObject(null);
    renderProps(null);
  }
  renderObjTree();
  pushHistory();
}

function selectObj(id) {
  selectedObjId = id;
  document.querySelectorAll('.obj-row').forEach(el => el.classList.toggle('selected', el.dataset.id===id));
  const obj = objects.find(o => o.id===id);
  BlockCanvas.switchObject(id);
  renderProps(obj);
  renderSceneObjProps(obj);
}

function renderObjTree() {
  const tree = $('object-tree');
  tree.innerHTML = '';
  objects.forEach(obj => {
    const row = document.createElement('div');
    row.className = 'obj-row' + (obj.id===selectedObjId ? ' selected' : '');
    row.dataset.id = obj.id;
    row.innerHTML = `
      <span class="obj-icon">${obj.icon}</span>
      <span class="obj-name">${escH(obj.name)}</span>
      <span class="obj-type">${obj.type}</span>
      <button class="obj-del" onclick="event.stopPropagation();deleteObj('${obj.id}')">√ó</button>
    `;
    row.addEventListener('click', () => selectObj(obj.id));
    tree.appendChild(row);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PROPERTIES PANEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderProps(obj) {
  const content = $('props-content');
  if (!obj) { content.innerHTML = '<div style="padding:10px;color:var(--text2);font-size:11px">Select an object</div>'; return; }

  const fields = [
    ['Name','name','text'],
    ['X','x','number'], ['Y','y','number'], ['Z','z','number'],
    ['Rot X','rotX','number'], ['Rot Y','rotY','number'], ['Rot Z','rotZ','number'],
    ['Scale X','scaleX','number'], ['Scale Y','scaleY','number'], ['Scale Z','scaleZ','number'],
    ['Color','color','color'],
    ['Speed','speed','number'],
    ['Health','health','number'],
    ['Tag','tag','text'],
    ['Physics','physics','checkbox'],
    ['Visible','visible','checkbox'],
  ];

  content.innerHTML = '';
  fields.forEach(([label, key, type]) => {
    const row = document.createElement('div');
    row.className = 'prop-row';
    const lbl = document.createElement('label');
    lbl.className = 'prop-label';
    lbl.textContent = label;
    row.appendChild(lbl);

    let input;
    if (type === 'checkbox') {
      input = document.createElement('input');
      input.type = 'checkbox';
      input.className = 'prop-check';
      input.checked = !!obj[key];
      input.onchange = () => {
        obj[key] = input.checked;
        Scene3D.updateObject(obj);
        pushHistory();
      };
    } else if (type === 'color') {
      input = document.createElement('input');
      input.type = 'color';
      input.className = 'prop-color';
      input.value = obj[key] || '#4488ff';
      input.oninput = () => { obj[key] = input.value; Scene3D.updateObject(obj); };
      input.onchange = () => pushHistory();
    } else {
      input = document.createElement('input');
      input.type = type === 'number' ? 'number' : 'text';
      input.className = 'prop-input';
      input.value = obj[key] !== undefined ? obj[key] : '';
      input.oninput = () => {
        obj[key] = type === 'number' ? (parseFloat(input.value)||0) : input.value;
        Scene3D.updateObject(obj);
      };
      input.onchange = () => pushHistory();
    }
    row.appendChild(input);
    content.appendChild(row);
  });
}

function renderSceneObjProps(obj) {
  const el = $('scene-obj-props');
  if (!obj) { el.innerHTML = '<div style="padding:10px;color:var(--text2);font-size:11px">Click an object in the viewport</div>'; return; }
  el.innerHTML = `
    <div style="padding:10px 12px">
      <div style="font-weight:600;margin-bottom:8px">${obj.icon} ${escH(obj.name)}</div>
      <div style="font-size:11px;color:var(--text2)">Type: ${obj.type}</div>
      <div style="font-size:11px;color:var(--text2);margin-top:3px">Pos: (${(obj.x||0).toFixed(2)}, ${(obj.y||0).toFixed(2)}, ${(obj.z||0).toFixed(2)})</div>
      <div style="font-size:11px;color:var(--text2);margin-top:3px">Rot: (${(obj.rotX||0).toFixed(1)}¬∞, ${(obj.rotY||0).toFixed(1)}¬∞, ${(obj.rotZ||0).toFixed(1)}¬∞)</div>
      <div style="font-size:11px;color:var(--text2);margin-top:3px">Scale: (${(obj.scaleX||1).toFixed(2)}, ${(obj.scaleY||1).toFixed(2)}, ${(obj.scaleZ||1).toFixed(2)})</div>
      <div style="font-size:11px;color:var(--text2);margin-top:3px">Physics: ${obj.physics?'‚úî':'‚Äî'} | Visible: ${obj.visible!==false?'‚úî':'‚Äî'}</div>
      ${obj.tag ? `<div style="font-size:11px;color:var(--text2);margin-top:3px">Tag: ${escH(obj.tag)}</div>` : ''}
    </div>
  `;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PALETTE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildPalette() {
  const container = $('palette-categories');
  container.innerHTML = '';
  BlockDefs.CATEGORIES.forEach(cat => {
    const catEl = document.createElement('div');
    catEl.className = 'pal-cat';

    const header = document.createElement('div');
    header.className = 'pal-cat-header';
    const arrow = document.createElement('span');
    arrow.className = 'pal-cat-arrow open';
    arrow.textContent = '‚ñæ';
    header.innerHTML = `<div class="pal-cat-dot" style="background:${cat.color}"></div>${cat.icon} ${cat.name}`;
    header.appendChild(arrow);

    const blocksEl = document.createElement('div');
    blocksEl.className = 'pal-cat-blocks';

    let collapsed = false;
    header.addEventListener('click', () => {
      collapsed = !collapsed;
      blocksEl.style.display = collapsed ? 'none' : '';
      arrow.textContent = collapsed ? '‚ñ∏' : '‚ñæ';
      arrow.className = 'pal-cat-arrow ' + (collapsed ? 'closed' : 'open');
    });

    cat.blocks.forEach(def => {
      const block = document.createElement('div');
      block.className = 'pal-block';
      block.draggable = true;
      block.dataset.blockId = def.id;
      block.style.borderLeft = `3px solid ${cat.color}`;
      block.innerHTML = `<span class="pal-block-icon" style="color:${cat.color}">${def.icon}</span><span class="pal-block-label">${escH(def.label)}</span>`;
      blocksEl.appendChild(block);
    });

    catEl.appendChild(header);
    catEl.appendChild(blocksEl);
    container.appendChild(catEl);
  });

  // Search filter
  $('palette-search').addEventListener('input', e => {
    const q = e.target.value.toLowerCase().trim();
    $('palette-categories').querySelectorAll('.pal-block').forEach(el => {
      const match = !q || el.querySelector('.pal-block-label').textContent.toLowerCase().includes(q) || el.dataset.blockId.includes(q);
      el.style.display = match ? '' : 'none';
    });
    $('palette-categories').querySelectorAll('.pal-cat').forEach(cat => {
      const visible = [...cat.querySelectorAll('.pal-block')].some(b => b.style.display !== 'none');
      cat.style.display = visible ? '' : 'none';
    });
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CODE EDITOR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
window.CodeEditor = (() => {
  const textarea = $('code-textarea');
  const highlight = $('code-highlight');
  const linenos = $('code-lines');
  let currentFile = 'game.js';

  function hl(code) {
    return code
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/(\/\/[^\n]*)/g,'<span class="cc">$1</span>')
      .replace(/\b(const|let|var|function|async|await|return|if|else|for|while|new|this|true|false|null|undefined|typeof|instanceof|class|extends|of|in|import|export|default|switch|case|break|continue|try|catch|finally|throw)\b/g,'<span class="ck">$1</span>')
      .replace(/("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|`(?:[^`\\]|\\.)*`)/g,'<span class="cs">$1</span>')
      .replace(/\b(\d+\.?\d*)\b/g,'<span class="cn">$1</span>')
      .replace(/\b([A-Z_][A-Z_0-9]{2,})\b/g,'<span class="co">$1</span>');
  }

  function getLineNums(code) {
    return code.split('\n').map((_,i)=>i+1).join('\n');
  }

  function syncDisplay() {
    const code = textarea.value;
    highlight.innerHTML = hl(code) + '\n';
    linenos.textContent = getLineNums(code);
    if (codeFiles[currentFile] !== undefined) codeFiles[currentFile] = code;
    syncScroll();
  }

  function syncScroll() {
    highlight.scrollTop = textarea.scrollTop;
    highlight.scrollLeft = textarea.scrollLeft;
    linenos.scrollTop = textarea.scrollTop;
  }

  function init() {
    codeFiles['game.js'] = DEFAULT_GAME_JS();
    textarea.addEventListener('input', () => { syncDisplay(); });
    textarea.addEventListener('scroll', syncScroll);
    textarea.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        e.preventDefault();
        const s = textarea.selectionStart, en = textarea.selectionEnd;
        textarea.value = textarea.value.slice(0,s) + '  ' + textarea.value.slice(en);
        textarea.selectionStart = textarea.selectionEnd = s+2;
        syncDisplay();
      }
    });
    loadFile('game.js');
    renderFileList();
  }

  function loadFile(name) {
    currentFile = name;
    $('code-file-label').textContent = name;
    textarea.value = codeFiles[name] || '';
    syncDisplay();
    renderFileList();
  }

  function renderFileList() {
    const list = $('script-list');
    if (!list) return;
    list.innerHTML = '';
    Object.keys(codeFiles).forEach(name => {
      const el = document.createElement('div');
      el.className = 'script-file' + (name===currentFile?' active':'');
      el.innerHTML = `<span>üìú</span> ${escH(name)}`;
      el.addEventListener('click', () => loadFile(name));
      el.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (name !== 'game.js' && confirm(`Delete "${name}"?`)) { delete codeFiles[name]; loadFile('game.js'); }
      });
      list.appendChild(el);
    });
  }

  function getFiles() { return codeFiles; }
  function getCurrentFile() { return currentFile; }
  function setFileContent(name, content, silent=false) {
    codeFiles[name] = content;
    if (currentFile === name && !silent) { textarea.value = content; syncDisplay(); }
    else if (currentFile === name) { highlight.innerHTML = hl(content) + '\n'; linenos.textContent = getLineNums(content); }
  }
  function refresh() { textarea.value = codeFiles[currentFile] || ''; syncDisplay(); }

  $('btn-new-script').addEventListener('click', () => {
    const name = prompt('Script filename:', 'helper.js');
    if (name && name.trim()) { codeFiles[name.trim()] = `// ${name.trim()}\n`; loadFile(name.trim()); }
  });
  $('btn-format').addEventListener('click', () => { syncDisplay(); consoleLog('Code refreshed.','success'); });
  $('btn-sync').addEventListener('click', () => CodeBridge.codeToBlocks());

  return { init, loadFile, renderFileList, getFiles, getCurrentFile, setFileContent, refresh };
})();

function DEFAULT_GAME_JS() {
  return `// game.js ‚Äî Custom game logic for Lorl
// This runs alongside your block scripts.
// The runtime API is available: __objs, __vars, __events, __moveBy(), __jump(), etc.

// Example: WASD movement for Player (or use blocks instead!)
window.__events.on('start', async function() {
  const player = __objs['Player_1_'] || Object.values(__objs).find(o => o.name === 'Player');
  if (!player) return;

  const keys = {};
  document.addEventListener('keydown', e => keys[e.code] = true);
  document.addEventListener('keyup', e => keys[e.code] = false);

  __events.on('update', function(dt) {
    const spd = (player.speed || 5) * dt;
    if (keys['KeyW'] || keys['ArrowUp'])    __moveBy(player, 0, 0, -spd);
    if (keys['KeyS'] || keys['ArrowDown'])  __moveBy(player, 0, 0,  spd);
    if (keys['KeyA'] || keys['ArrowLeft'])  __moveBy(player, -spd, 0, 0);
    if (keys['KeyD'] || keys['ArrowRight']) __moveBy(player,  spd, 0, 0);
    if (keys['Space'] && player._grounded)  __jump(player, 9);
  });
});
`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BLOCK CANVAS (load after DOM)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// (blockcanvas.js uses these globals, so we load it via script tag below)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CODE GENERATION (codegen.js)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PREVIEW
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
$('btn-preview').addEventListener('click', runPreview);
$('btn-stop').addEventListener('click', stopPreview);
$('btn-popout').addEventListener('click', () => {
  const html = buildGameHTML();
  const w = window.open('','_blank');
  if (w) { w.document.write(html); w.document.close(); }
});

function runPreview() {
  consoleLog('Building game‚Ä¶','info');
  try {
    const html = buildGameHTML();
    $('preview-cover').style.display = 'none';
    $('btn-preview').style.display = 'none';
    $('btn-stop').style.display = '';
    const blob = new Blob([html],{type:'text/html'});
    const url = URL.createObjectURL(blob);
    $('preview-frame').src = url;
    $('preview-frame').onload = () => {
      URL.revokeObjectURL(url);
      try {
        const fw = $('preview-frame').contentWindow;
        ['log','warn','error'].forEach(level => {
          const orig = fw.console[level].bind(fw.console);
          fw.console[level] = (...a) => { orig(...a); consoleLog(a.join(' '), level==='log'?'info':level); };
        });
      } catch(_) {}
    };
    consoleLog('Preview running!','success');
  } catch(e) {
    consoleLog('Build error: '+e.message,'error');
    console.error(e);
  }
}

function stopPreview() {
  $('preview-frame').src = 'about:blank';
  $('preview-cover').style.display = '';
  $('btn-preview').style.display = '';
  $('btn-stop').style.display = 'none';
}

function buildGameHTML() {
  const name = $('project-name').value || 'Lorl Game';
  const blockScripts = BlockCanvas.serialize();
  const customFiles = Object.entries(codeFiles).map(([name,content]) => ({ name, content }));
  const gameJS = CodeGen.generateGameJS(objects, blockScripts, customFiles, assets);

  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>${escH(name)}</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
body{background:#0a0a12;overflow:hidden;width:100vw;height:100vh;font-family:sans-serif}
#game-canvas{display:block;width:100%;height:100%}
#hud{position:fixed;inset:0;pointer-events:none;z-index:100}
</style>
</head>
<body>
<canvas id="game-canvas"></canvas>
<div id="hud"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>
<script>
window.__assetUrls = {};
// Lorl platform bridge
window.addEventListener('message', e=>{
  if(e.data&&e.data.lorlInit){
    const{serverUrl,roomId,username}=e.data.lorlInit;
    if(window.Lorl) Lorl._init(serverUrl,roomId,username);
  }
});
window.addEventListener('load',()=>{
  window.parent&&window.parent.postMessage({lorlReady:true},'*');
});
<\/script>
<script>
${gameJS}
<\/script>
</body>
</html>`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  EXPORT / IMPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
$('btn-export').addEventListener('click', exportGame);
$('btn-import').addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type='file'; inp.accept='.lorlgame,.zip';
  inp.onchange = e => importGame(e.target.files[0]);
  inp.click();
});

async function exportGame() {
  if (typeof JSZip === 'undefined') { consoleLog('JSZip not loaded!','error'); return; }
  const name = $('project-name').value.trim() || 'MyGame';
  const id = name.toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_]/g,'');

  const blockScripts = BlockCanvas.serialize();
  const customFiles = Object.entries(codeFiles).map(([n,c]) => ({ name:n, content:c }));
  const gameJS = CodeGen.generateGameJS(objects, blockScripts, customFiles, assets);

  const manifest = {
    id, name,
    author: 'Lorl Studio',
    version: '1.0.0',
    lorlVersion: '2',
    created: new Date().toISOString(),
    // Studio data embedded for re-importing
    __studioData: {
      objects,
      blockScripts,
      codeFiles,
      assetNames: assets.map(a => ({ id:a.id, name:a.name, type:a.type })),
    }
  };

  const html = buildGameHTML();
  const zip = new JSZip();
  zip.file('manifest.json', JSON.stringify(manifest, null, 2));
  zip.file('index.html', html);

  // Embed assets
  assets.forEach(a => {
    const folder = a.type==='texture'?'assets/textures/': a.type==='audio'?'assets/sounds/':'assets/models/';
    // Assets stored as data URIs in manifest for simplicity (consistent with Platform)
  });

  const blob = await zip.generateAsync({ type:'blob', compression:'DEFLATE', compressionOptions:{ level:6 } });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=id+'.lorlgame'; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 3000);
  consoleLog(`Exported: ${name}.lorlgame`,'success');
}

async function importGame(file) {
  if (!file) return;
  if (typeof JSZip === 'undefined') { consoleLog('JSZip not loaded!','error'); return; }
  try {
    const zip = await JSZip.loadAsync(file);
    const mf = zip.file('manifest.json');
    if (!mf) { consoleLog('Invalid .lorlgame: missing manifest.json','error'); return; }
    const manifest = JSON.parse(await mf.async('string'));
    $('project-name').value = manifest.name || file.name;

    if (manifest.__studioData) {
      const sd = manifest.__studioData;
      // Clear scene
      objects.forEach(o => Scene3D.removeObject(o.id));
      objects = sd.objects || [];
      _objSeq = objects.length;
      if (Scene3D.isInitialized()) objects.forEach(o => Scene3D.addObject(o));
      renderObjTree();

      // Restore blocks
      if (sd.blockScripts) BlockCanvas.deserialize(sd.blockScripts);

      // Restore code
      if (sd.codeFiles) {
        Object.assign(codeFiles, sd.codeFiles);
        CodeEditor.renderFileList();
        CodeEditor.refresh();
      }

      if (objects.length > 0) selectObj(objects[0].id);
      consoleLog(`Imported: ${manifest.name}`,'success');
    } else {
      consoleLog('Imported game (play-only format ‚Äî no studio data)','warn');
    }
  } catch(e) {
    consoleLog('Import failed: '+e.message,'error');
    console.error(e);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ASSETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const dropZone = $('asset-drop-zone');
dropZone.addEventListener('click', () => $('asset-file-input').click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('over'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('over'));
dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('over'); handleAssets(e.dataTransfer.files); });
$('asset-file-input').addEventListener('change', e => handleAssets(e.target.files));

function handleAssets(files) {
  Array.from(files).forEach(file => {
    const reader = new FileReader();
    reader.onload = ev => {
      const ext = file.name.split('.').pop().toLowerCase();
      const type = file.type.startsWith('image/')?'texture': file.type.startsWith('audio/')?'audio':'model';
      const asset = { id:'asset_'+Date.now()+'_'+Math.random().toString(36).slice(2,5), name:file.name, type, data:ev.target.result, mime:file.type };
      assets.push(asset);
      renderAssets();
      consoleLog(`Imported asset: ${file.name}`,'success');
    };
    reader.readAsDataURL(file);
  });
}

function renderAssets() {
  const grid = $('asset-grid');
  grid.innerHTML = '';
  assets.forEach((a, idx) => {
    const card = document.createElement('div');
    card.className = 'asset-card';
    const icons = { texture:'üñºÔ∏è', audio:'üîä', model:'üì¶' };
    const thumb = a.type==='texture'
      ? `<img src="${a.data}" alt="${escH(a.name)}"/>`
      : `<span style="font-size:32px">${icons[a.type]||'üìÅ'}</span>`;
    card.innerHTML = `<div class="asset-thumb">${thumb}</div><div class="asset-name">${escH(a.name)}</div><div class="asset-type-badge">${a.type}</div>`;
    card.title = 'Right-click to delete';
    card.addEventListener('contextmenu', e => {
      e.preventDefault();
      if (confirm(`Delete asset "${a.name}"?`)) { assets.splice(idx,1); renderAssets(); }
    });
    grid.appendChild(card);
  });
}

// Also expose getAssets for CodeGen
window.Assets = { getAssets: () => assets };

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SCENE TAB CONTROLS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.querySelectorAll('[data-tool]').forEach(btn => {
  btn.addEventListener('click', () => Scene3D.setTool(btn.dataset.tool));
});
document.querySelectorAll('[data-add]').forEach(btn => {
  btn.addEventListener('click', () => { addObj(btn.dataset.add); if (activeTab !== 'scene') switchTab('scene'); });
});
document.querySelectorAll('.view-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.view-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    Scene3D.setView(btn.dataset.view);
  });
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ADD OBJECT MODAL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showModal(id) { $('modal-backdrop').classList.add('show'); $(id).classList.add('show'); }
function closeModal() { $('modal-backdrop').classList.remove('show'); document.querySelectorAll('.modal').forEach(m=>m.classList.remove('show')); }
$('modal-backdrop').addEventListener('click', closeModal);
$('btn-cancel-obj').addEventListener('click', closeModal);
$('btn-add-obj').addEventListener('click', () => { $('new-obj-name').value=''; showModal('modal-add-obj'); });
document.querySelectorAll('.type-card').forEach(card => {
  card.addEventListener('click', () => {
    addObj(card.dataset.type, $('new-obj-name').value.trim() || null);
    closeModal();
  });
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UNDO / REDO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function pushHistory() {
  const state = { objects: JSON.parse(JSON.stringify(objects)) };
  history = history.slice(0, histIdx+1);
  history.push(JSON.stringify(state));
  if (history.length > MAX_HIST) history.shift();
  histIdx = history.length-1;
}
function restoreState(stateStr) {
  try {
    const state = JSON.parse(stateStr);
    objects.forEach(o=>Scene3D.removeObject(o.id));
    objects = state.objects || [];
    if (Scene3D.isInitialized()) objects.forEach(o=>Scene3D.addObject(o));
    renderObjTree();
    if (selectedObjId && !objects.find(o=>o.id===selectedObjId)) { selectedObjId=null; BlockCanvas.switchObject(null); renderProps(null); }
  } catch(e) {}
}
$('btn-undo').addEventListener('click', () => { if (histIdx > 0) { histIdx--; restoreState(history[histIdx]); consoleLog('Undo','info'); } });
$('btn-redo').addEventListener('click', () => { if (histIdx < history.length-1) { histIdx++; restoreState(history[histIdx]); consoleLog('Redo','info'); } });
document.addEventListener('keydown', e => {
  if ((e.ctrlKey||e.metaKey) && e.key==='z' && !e.shiftKey) { e.preventDefault(); $('btn-undo').click(); }
  if ((e.ctrlKey||e.metaKey) && (e.key==='y' || (e.key==='z' && e.shiftKey))) { e.preventDefault(); $('btn-redo').click(); }
  if (e.key==='Escape') { $('tutorial-overlay').classList.remove('show'); closeModal(); }
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CONSOLE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function consoleLog(msg, level='info') {
  const out = $('console-out');
  const line = document.createElement('div');
  line.className = 'cline';
  const t = new Date().toLocaleTimeString('en',{hour12:false,hour:'2-digit',minute:'2-digit',second:'2-digit'});
  line.innerHTML = `<span class="ctime">${t}</span><span class="cmsg ${level}">${escH(String(msg))}</span>`;
  out.appendChild(line);
  out.scrollTop = out.scrollHeight;
}
$('btn-clear-console').addEventListener('click', () => $('console-out').innerHTML='');

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TUTORIALS (Scratch-style)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const TUTORIALS = [
  {
    title: 'Welcome to Lorl Studio! üéÆ',
    body: `
      <div class="tut-text">Lorl Studio is a browser-based 3D game editor. Build games visually with blocks (like Scratch!), write JavaScript, design 3D scenes ‚Äî all in one place. No installation required.</div>
      <div class="tut-callout">üí° <b>Your game runs entirely in the browser</b> and exports as a <code>.lorlgame</code> file that works with the Lorl Platform for sharing and multiplayer.</div>
    `
  },
  {
    title: 'üß© Scratch-style Block Coding',
    body: `
      <div class="tut-text">The <b>Blocks</b> tab works just like Scratch. Pick an object from the left panel, then <b>drag blocks from the palette</b> onto the canvas to build scripts.</div>
      <div class="tut-callout">üöÄ <b>Try it:</b><br>1. Click "Player" in the left panel<br>2. Drag "When game starts" from the Events palette<br>3. Drag "Enable physics" below it<br>4. Press ‚ñ∂ Preview!</div>
      <div class="tut-text">Hat blocks (events) start a script. Stack blocks run in order. C-blocks (loops, if) contain other blocks inside them.</div>
    `
  },
  {
    title: 'üíª Code Editor & Bi-directional Sync',
    body: `
      <div class="tut-text">Switch to the <b>Code</b> tab to see and edit the JavaScript generated from your blocks. Changes stay in sync both ways!</div>
      <div class="tut-callout">üîÑ <b>Two-way sync:</b><br>‚Ä¢ Edit blocks ‚Üí code auto-updates immediately<br>‚Ä¢ Edit code ‚Üí click <b>‚Üî Sync Blocks</b> to update blocks<br>‚Ä¢ Code you write that doesn't match a block becomes a <b>Custom Code</b> block</div>
      <div class="tut-code">// Example from blocks:
__events.on('start', async function() {
  __enablePhysics(self);
  __jump(self, 9);
});</div>
    `
  },
  {
    title: 'üßä 3D Scene Editor',
    body: `
      <div class="tut-text">The <b>Scene</b> tab gives you a full Three.js 3D viewport. Click objects to select them. The toolbar lets you switch between Select, Move, Rotate, and Scale tools.</div>
      <div class="tut-callout">üñ±Ô∏è <b>Navigation:</b><br>‚Ä¢ <b>Right-click drag</b> = Orbit camera<br>‚Ä¢ <b>Shift + right-click drag</b> = Pan<br>‚Ä¢ <b>Scroll wheel</b> = Zoom<br>‚Ä¢ <b>Click object</b> = Select it</div>
      <div class="tut-text">Use the toolbar buttons to add Cubes, Spheres, Characters, Lights and more. Properties update live as you move objects.</div>
    `
  },
  {
    title: 'üñº Assets',
    body: `
      <div class="tut-text">The <b>Assets</b> tab lets you import images, sounds, and 3D models. Drop files onto the zone or click to browse.</div>
      <div class="tut-callout">üì¶ <b>Supported formats:</b><br>‚Ä¢ Images: PNG, JPG, WebP, GIF<br>‚Ä¢ Audio: MP3, OGG, WAV<br>‚Ä¢ 3D Models: OBJ, GLTF, GLB</div>
      <div class="tut-text">Imported assets are available in block fields (like "Set texture" or "Play sound"). They're embedded in your exported game file.</div>
    `
  },
  {
    title: 'üì¶ File Format: Studio ‚Üî Platform',
    body: `
      <div class="tut-text">The <code>.lorlgame</code> format is a ZIP that works consistently between Studio and Platform. Exporting from Studio creates a file that:</div>
      <div class="tut-callout">‚úÖ Contains <b>index.html</b> ‚Äî the full playable game<br>‚úÖ Contains <b>manifest.json</b> ‚Äî game metadata + all studio data<br>‚úÖ Can be <b>imported back into Studio</b> to continue editing<br>‚úÖ Can be opened in <b>Lorl Platform</b> to play or share</div>
      <div class="tut-text">Your blocks, code, scene, and assets are all preserved inside the manifest. Import a .lorlgame to pick up exactly where you left off.</div>
    `
  },
  {
    title: 'üöÄ Ready to build!',
    body: `
      <div class="tut-text">You're all set! Here's a quick guide to making your first game:</div>
      <div class="tut-callout">
        1Ô∏è‚É£ Add a <b>Plane</b> object (the ground)<br>
        2Ô∏è‚É£ Add a <b>Character</b> object (the player)<br>
        3Ô∏è‚É£ Go to <b>Blocks</b>, select Player, add <b>"When game starts"</b> and <b>"Enable physics"</b><br>
        4Ô∏è‚É£ Add an <b>"Every frame"</b> hat and move blocks for WASD<br>
        5Ô∏è‚É£ Press <b>‚ñ∂ Preview</b> to test!<br>
        6Ô∏è‚É£ Press <b>‚¨á Export</b> to share as a .lorlgame
      </div>
      <div class="tut-text">You can reopen this tutorial any time with the üìñ Tutorial button. Happy building!</div>
    `
  },
];

let tutStep = 0;
function showTutorial(step) {
  tutStep = Math.max(0, Math.min(TUTORIALS.length-1, step));
  const tut = TUTORIALS[tutStep];
  $('tut-step-pill').textContent = `Step ${tutStep+1} of ${TUTORIALS.length}`;
  $('tut-title').textContent = tut.title;
  $('tut-body').innerHTML = tut.body;
  const dots = $('tut-dots');
  dots.innerHTML = '';
  TUTORIALS.forEach((_,i) => {
    const dot = document.createElement('div');
    dot.className = 'tut-dot' + (i===tutStep?' active':'');
    dot.addEventListener('click', () => showTutorial(i));
    dots.appendChild(dot);
  });
  $('tut-next').textContent = tutStep===TUTORIALS.length-1 ? 'Start Building! üöÄ' : 'Next ‚Üí';
  $('tutorial-overlay').classList.add('show');
}
$('btn-tutorial').addEventListener('click', () => showTutorial(0));
$('tut-skip').addEventListener('click', () => $('tutorial-overlay').classList.remove('show'));
$('tut-next').addEventListener('click', () => {
  if (tutStep < TUTORIALS.length-1) showTutorial(tutStep+1);
  else $('tutorial-overlay').classList.remove('show');
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function init() {
  buildPalette();
  CodeEditor.init();

  // Starter scene
  const ground = addObj('plane', 'Ground');
  ground.scaleX = 20; ground.scaleZ = 20; ground.y = 0; ground.color = '#152030';
  ground.physics = false;

  const player = addObj('character', 'Player');
  player.x = 0; player.y = 0.5; player.z = 0;
  player.color = '#00c896';
  player.physics = true; player.speed = 6;

  selectObj(player.id);
  pushHistory();

  consoleLog('Lorl Studio ready! üéÆ', 'success');
  consoleLog('üìñ Click Tutorial to get started, or dive straight in.', 'info');

  // Show tutorial on first load
  setTimeout(() => showTutorial(0), 600);
}

// Load block modules then init
function loadScript(src, cb) {
  const s = document.createElement('script');
  s.src = src; s.onload = cb;
  document.head.appendChild(s);
}

init();
</script>
</body>
</html>